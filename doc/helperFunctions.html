<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.9.1" />
<title>helperFunctions API documentation</title>
<meta name="description" content="" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>helperFunctions</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">#!/usr/bin/env python3

import os
import json
import sys
import yaml
import subprocess
from os.path import dirname, abspath
import traceback
import logging
import logging.handlers
import uuid
from datetime import datetime
import io
import requests
import copy
from os import path
from subprocess import check_output
import simplejson
import re
import atexit
from packaging import version



__author__ = &#34;Stefan Herdy&#34;
__credits__ = [&#34;Heimo Müller&#34;, &#34;Robert Reihs &#34;, &#34;Markus Plass&#34;,]
__license__ = &#34;...&#34;
__version__ = &#34;1.0.1&#34;
__email__ = &#34;stefan.herdy@medunigraz.at&#34;
__status__ = &#34;Development&#34;



class AppController:

    def __init__(self):
        self.rootdir = dirname(dirname(abspath(__file__)))
        self.appPath = self.rootdir + &#39;/application-instance&#39;
        with open(self.rootdir + &#39;/environment-parameters.json&#39;) as infofile:
            params = json.load(infofile)
            domain = params[0][&#39;DOMAIN_NAME&#39;]
        
    def __del__(self):
        try:
            jobID = AppController.createJobID(self)
            instanceName = self.instanceName
            AppController.unlock(self, jobID, instanceName, end = True)
        except:
            pass

    def createJobID(self):
        &#39;&#39;&#39;
        Description:
        -----------
        Creates a unique JobID to be able to identify every single job.

        Parameters:
        ----------

        Raises:
        -------
        
        Returns:
        -------
        Job ID : str
            Unique JobID that consists of an uuid and the current datetime
        &#39;&#39;&#39;
        jobID = str(uuid.uuid1())
        dateObj = datetime.now()
        datestring = str(dateObj.year) + &#39;-&#39; + str(dateObj.month) + &#39;-&#39; + str(dateObj.day) + &#39;-&#39; + str(dateObj.microsecond)
        jobID = jobID + datestring
        return jobID

    def checkExists(self, jobID, instanceName, install):
        &#39;&#39;&#39;
        Description:
        -----------
        Checks if an app with the wanted name does already exist.

        Parameters:
        ----------
        Job ID : str
            Unique JobID that consists of an uuid and the datetime

        instanceName : str
            The instance name of the application that is used 

        install: bool
            Is the method performed during Installation?
            For installation, its necessary that the app does not exist, 
            but for start, stop, coppy ... of an app it is important that the app already exists.

        Raises:
        -------
        if install == True:

            if exists == True

                raise Exception(&#39;The app you want to install does already exist!&#39;)

        if install == False:

            if exists == False:

                raise Exception(&#39;The app you want to use does not exist!&#39;)

        Returns:
        -------
        
        &#39;&#39;&#39;
        rootdir = dirname(dirname(abspath(__file__)))
        bibbox_logger = AppController.setUpLog(self, jobID, instanceName, systemonly=True)
        appPath = rootdir + &#39;/application-instance/&#39;
        bibbox_logger.info(&#39;Check if app folder exists&#39;)
        if path.exists(appPath) == False:
            process = subprocess.Popen([&#39;mkdir&#39;, appPath])
            output, error = process.communicate()
            if output:
                bibbox_logger.debug( str(output))
        if instanceName in os.listdir(appPath):
            exists = True
        else:
            exists = False
        if install == True:
            if exists == True:
                bibbox_logger.info(&#39;The app you want to install does already exist! App: &#39; + instanceName)
                raise Exception(&#39;The app you want to install does already exist! App: &#39; + instanceName)
        if install == False:
            if exists == False:
                bibbox_logger.info(&#39;The app you want to use does not exist! App: &#39; + instanceName)
                raise Exception(&#39;The app you want to use does not exist! App: &#39; + instanceName)

    def createFolder(self, jobID, instanceName):
        &#39;&#39;&#39;
        Description:
        -----------
        Creates destination folder for app repository.

        Parameters:
        ----------
        Job ID : str
            Unique JobID that consists of an uuid and the datetime

        instanceName : str
            The instance name of the application that is used 
        
        Raises:
        -------
        

        Returns:
        -------
        
        &#39;&#39;&#39;
        bibbox_logger = AppController.setUpLog(self, jobID, instanceName, systemonly=True)
        bibbox_logger.info(&#39;Check if app folder exists&#39;)
        rootdir = dirname(dirname(abspath(__file__)))
        appPath = rootdir + &#39;/application-instance&#39;
        if path.exists(appPath) == False:
            bibbox_logger.error( &#39;Error While creating folder for application &#39; + instanceName + &#39;. The folder &#34;/application-instance&#34; does not exist!&#39;)
            raise Exception(&#39;Error While creating folder for application &#39; + instanceName + &#39;. The folder &#34;/application-instance&#34; does not exist!&#39;)
        process = subprocess.Popen([&#39;mkdir&#39; , appPath + &#39;/&#39; + instanceName])
        output, error = process.communicate()
        if output:
            bibbox_logger.debug( str(output))
        process = subprocess.Popen([&#39;mkdir&#39; , appPath + &#39;/&#39; + instanceName + &#39;/log/&#39;])
        output, error = process.communicate()
        if output:
            bibbox_logger.debug( str(output))
        if path.exists(appPath + &#39;/&#39; + instanceName) == False:
            bibbox_logger.error( &#39;Error While creating folder for application &#39; + instanceName + &#39;. The folder &#34;/application-instance/&#39; + instanceName + &#39;/&#34; does not exist!&#39;)
            raise Exception(&#39;Error While creating folder for application &#39; + instanceName + &#39;. The folder &#34;/application-instance&#34; does not exist!&#39;)
        if path.exists(appPath + &#39;/&#39; + instanceName + &#39;/log/&#39;) == False:
            bibbox_logger.error( &#39;Error While creating folder for application &#39; + instanceName + &#39;. The folder &#34;/application-instance&#39; + instanceName + &#39;/log/&#34; does not exist!&#39;)
            raise Exception(&#39;Error While creating folder for application &#39; + instanceName + &#39;. The folder &#34;/application-instance&#34; does not exist!&#39;)

    def setup_logger(self, jobID, loggerName, log_file, level=logging.DEBUG):
        &#39;&#39;&#39;
        Description:
        -----------
        Sets up logger.

        Parameters:
        ----------
        Job ID : str
            Unique JobID that consists of an uuid and the datetime

        loggerName : str
            Name of the logger 

        logfile : str
            Path like object that defines the logfile destination and the logfile&#39;s name
        
        Raises:
        -------
        

        Returns:
        -------
        
        &#39;&#39;&#39;
        
        formatter = logging.Formatter(&#39;%(asctime)s - %(levelname)s - %(name)s - %(message)s&#39;)
        logformatter = logging.Formatter(jobID + &#39;%(asctime)s - %(levelname)s - %(name)s - %(message)s&#39;)
        logger = logging.getLogger(loggerName)
        if logger.handlers[:] == []:
            handler = logging.handlers.RotatingFileHandler(log_file, maxBytes=20000000, backupCount = 10)
            handler.setFormatter(logformatter)
            stream = logging.StreamHandler()
            stream.setFormatter(formatter)
            logger.addHandler(stream)
            logger.addHandler(handler)
        logger.setLevel(level)

        return logger
    
    def setUpLog(self, jobID, instanceName, systemonly = False):
        &#39;&#39;&#39;
        Description:
        -----------
        Sets up initial log settings, such as format, file name etc.

        Parameters:
        ----------
        Job ID : str
            Unique JobID that consists of an uuid and the datetime

        instanceName : str
            The instance name of the application that is used 
        
        Raises:
        -------
        

        Returns:
        -------
        
        &#39;&#39;&#39;
        rootdir = dirname(dirname(abspath(__file__)))
        if systemonly == False:
            appPath = rootdir + &#39;/application-instance&#39;
            if path.exists(appPath) == False:
                raise Exception( &#39; - The folder &#34;/application-instance/&#34; does not exist!&#39;)
            logpath = appPath + &#39;/&#39; + instanceName + &#39;/log/&#39;
            if path.exists(logpath) == False:
                raise Exception( &#39; - The folder &#34;/application-instance/&#39; + instanceName + &#39;/log/&#34; does not exist!&#39;)
            app_logger = AppController.setup_logger(self, jobID, instanceName + &#39;-app.log&#39;, logpath + &#39;debug.log&#39;, level=logging.DEBUG)
            app_errorlogger = AppController.setup_logger(self, jobID, instanceName + &#39;-apperror.log&#39;, logpath + &#39;error.log&#39;, level=logging.DEBUG)
            docker_logger = AppController.setup_logger(self, jobID, instanceName + &#39;-docker.log&#39;, logpath + &#39;docker.log&#39;, level=logging.DEBUG)
            bibbox_logger = AppController.setup_logger(self, jobID, instanceName + &#39;-bibbox.log&#39;, rootdir + &#39;/log/system.log&#39;, level=logging.DEBUG)
            
            if path.exists(logpath + &#39;debug.log&#39;) == False:
                raise Exception(&#39;Error while creating logfile &#34;debug.log&#34; in folder &#39; + logpath + &#39;.&#39;)
            if path.exists(logpath + &#39;error.log&#39;) == False:
                raise Exception(&#39;Error while creating logfile &#34;error.log&#34; in folder &#39; + logpath + &#39;.&#39;)
            if path.exists(logpath + &#39;docker.log&#39;) == False:
                raise Exception(&#39;Error while creating logfile &#34;docker.log&#34; in folder &#39; + logpath + &#39;.&#39;)
            if path.exists(rootdir + &#39;/log/system.log&#39;) == False:
                raise Exception(&#39;Error while creating logfile &#34;system.log&#34; in folder &#39; + logpath + &#39;.&#39;)
            
            return app_logger, bibbox_logger, docker_logger, app_errorlogger
        else:
            bibbox_logger = AppController.setup_logger(self, jobID, instanceName + &#39;bibbox&#39;, rootdir + &#39;/log/system.log&#39;, level=logging.DEBUG)
            if path.exists(rootdir + &#39;/log/system.log&#39;) == False:
                raise Exception(&#39;Error while creating logfile &#34;system.log&#34;&#39;)
            
            return bibbox_logger

    
    def setStatus(self, jobID, status, instanceName):
        &#39;&#39;&#39;
        Description:
        -----------
        Sets the current ststus of an app and writes it to a file calles STATUS.

        Parameters:
        ----------
        Job ID : str
            Unique JobID that consists of an uuid and the datetime

        status: str
            The wanted ststus that gets written to the STATUS file

        instanceName : str
            The instance name of the application that is used 
        
        Raises:
        -------
        

        Returns:
        -------
        
        &#39;&#39;&#39;

        app_logger, bibbox_logger, docker_logger, app_errorlogger = AppController.setUpLog(self, jobID, instanceName)
        app_logger.info(&#39;Set status to &#39; + status )
        rootdir = dirname(dirname(abspath(__file__)))
        appPath = rootdir + &#39;/application-instance&#39;
        if path.exists(appPath) == False:
            app_errorlogger.error( &#39; - The folder &#34;/application-instance&#34; does not exist!&#39;)
        process = subprocess.Popen([&#39;touch&#39; , appPath + &#39;/&#39; + instanceName + &#39;/STATUS&#39;], stdout=subprocess.PIPE, stderr=subprocess.STDOUT)
        output, error = process.communicate()
        if output:
            app_errorlogger.error( str(output))
        try:
            text_file = open(appPath + &#39;/&#39; + instanceName + &#39;/STATUS&#39;, &#34;w&#34;)
            text_file.write(status)
            text_file.close()
        except Exception:
            app_errorlogger.exception(&#39;Fatal error in writing to STATUS file: &#39;, exc_info=True)
            raise Exception(&#39;Fatal error in writing to STATUS file: &#39;)
        if path.exists(appPath + &#39;/&#39; + instanceName + &#39;/STATUS&#39;) == False:
            app_errorlogger.exception(&#39;Something went wrong during writing to STATUS file: &#39;, exc_info=True)
            raise Exception(&#39;Fatal error in writing to STATUS file: &#39;)


    def lock(self, jobID, instanceName):
        &#39;&#39;&#39;
        Description:
        -----------
        Creates a file named LOCK to lock an app, so that no one is able to perform other operations
        on an app before the current operation is finished.

        Parameters:
        ----------
        Job ID : str
            Unique JobID that consists of an uuid and the datetime

        instanceName : str
            The instance name of the application that is used 
        
        Raises:
        -------
        Exception(&#39;The app you want to use is currently locked! Please try again later!&#39;) if the wanted app is currently locked.

        Returns:
        -------
        
        &#39;&#39;&#39;

        app_logger, bibbox_logger, docker_logger, app_errorlogger = AppController.setUpLog(self, jobID, instanceName)
        app_logger.info( &#39;Ckeck if app is locked&#39; )
        rootdir = dirname(dirname(abspath(__file__)))
        appPath = rootdir + &#39;/application-instance&#39;
        if path.exists(appPath) == False:
            app_errorlogger.error(&#39; - The folder &#34;/application-instance&#34; does not exist!&#39;)
        if &#39;LOCK&#39; in os.listdir(appPath + &#39;/&#39; + instanceName):
            try:
                with open(appPath + &#39;/&#39; + instanceName + &#39;/LOCK&#39;) as lockfile:
                    lockID = lockfile.read()
                    if lockID != jobID:
                        app_errorlogger.exception( &#39; - The app you want to use is currently locked! Please try again later!&#39;)
                        raise Exception(&#39;The app you want to use is currently locked! Please try again later!&#39;)
            except Exception:
                app_errorlogger.exception(&#39;Fatal error in writing to LOCK file: &#39;, exc_info=True)
                raise Exception(&#39;Could not open LOCK file in application folder!&#39;)

        app_logger.debug( &#39;Locking app: &#39; + instanceName )
        process = subprocess.Popen([&#39;touch&#39; , appPath + &#39;/&#39; + instanceName + &#39;/LOCK&#39;], stdout=subprocess.PIPE, stderr=subprocess.STDOUT)
        output, error = process.communicate()
        if output:
            app_errorlogger.error(str(output) )
        if path.exists(appPath + &#39;/&#39; + instanceName + &#39;/LOCK&#39;) == False:
            app_errorlogger.exception(&#39;Something went wrong during writing LOCK file: &#39;, exc_info=True)
            raise Exception(&#39;Fatal error in writing LOCK file: &#39;)

    def unlock(self, jobID, instanceName, end = False):
        &#39;&#39;&#39;
        Description:
        -----------
        Deletes a file named LOCK to lock an app, so that one is able to perform other operations
        on an app after the current operation is finished.

        Parameters:
        ----------
        Job ID : str
            Unique JobID that consists of an uuid and the datetime

        instanceName : str
            The instance name of the application that is used 
        
        Raises:
        -------

        Returns:
        -------
        
        &#39;&#39;&#39;
        rootdir = dirname(dirname(abspath(__file__)))
        appPath = rootdir + &#39;/application-instance&#39;
        if path.exists(appPath) == False:
            app_errorlogger.error(&#39; - The folder &#34;/application-instance&#34; does not exist!&#39;)
        process = subprocess.Popen([&#39;rm&#39; , appPath + &#39;/&#39; + instanceName + &#39;/LOCK&#39;], stdout=subprocess.PIPE, stderr=subprocess.STDOUT)
        output, error = process.communicate()
        if end == False:
            if output:
                app_errorlogger.error(str(output) )
        if path.exists(appPath + &#39;/&#39; + instanceName + &#39;/LOCK&#39;) == True:
            app_errorlogger.exception(&#39;Something went wrong during deleting LOCK file: &#39;, exc_info=True)
            raise Exception(&#39;Fatal error in deleting LOCK file: &#39;)
        app_logger, bibbox_logger, docker_logger, app_errorlogger = AppController.setUpLog(self, jobID, instanceName)
        app_logger.debug(&#39;App &#39; + instanceName + &#39; unlocked&#39;)


    def downloadApp(self, jobID, instanceName,appName,version = &#39;master&#39;):
        &#39;&#39;&#39;
        Description:
        -----------
        Downloads the wanted app from Github before installation.

        Parameters:
        ----------
        Job ID : str
            Unique JobID that consists of an uuid and the datetime

        instanceName : str
            The instance name of the application that is used 

        appName : str
            The (github) name of the application that is used 

        version : str
            The wanted version of the application that is used 
        
        Raises:
        -------

        Returns:
        -------
        
        &#39;&#39;&#39;
        if version == &#39;&#39; or version == None:
            version = &#39;master&#39;
        bibbox_logger = AppController.setUpLog(self, jobID, &#39;system&#39;, systemonly=True)
        try:
            url = &#39;https://raw.githubusercontent.com/bibbox/application-store/master/bibboxV4.json&#39;
            download = requests.get(url).content
        except Exception:
            raise Exception(&#39;Something went wrong during connecting to the GitHub repository. Please Check your internet connection!&#39;)
        try:
            params = simplejson.loads(download)
        except Exception:
            bibbox_logger.exception(&#39;Error while loading bibboxV4.json file: &#39;, exc_info=True)
            raise Exception(&#39;Error while loading bibboxV4.json file&#39;)
        appslist=[]
        
        appNameNew = &#39;app-&#39;+ appName     
        rootdir = dirname(dirname(abspath(__file__)))
        print(rootdir)
        #rootdir = &#39;opt/bibbox/sys-bibbox&#39;
        appPath = rootdir + &#39;/application-instance&#39;
        if path.exists(appPath) == False:
            raise Exception(&#39;The folder &#34;/application-instance&#34; does not exist!&#39;)
        app_logger, bibbox_logger, docker_logger, app_errorlogger = AppController.setUpLog(self, jobID, instanceName)
        app_logger.info( &#39;Downloading app: &#39; + appNameNew + &#39;/&#39; + instanceName + &#39; V:&#39; + version)
        
        process = subprocess.Popen([&#39;git&#39;, &#39;clone&#39;,&#39;-b&#39;, version, &#39;https://github.com/bibbox/&#39; + appNameNew + &#39;.git&#39;, rootdir + &#39;/application-instance/&#39; + instanceName + &#39;/repo/&#39;],text=True, stdout=subprocess.PIPE, stderr=subprocess.STDOUT)
        output, error = process.communicate()
        if output:
            app_logger.debug(str(output).rstrip() )
        if path.exists(appPath + &#39;/&#39; + instanceName + &#39;/repo&#39;) == False:
            app_errorlogger.exception(&#39;Something went wrong during downloading app: &#39; + instanceName, exc_info=True)
            raise Exception(&#39;Fatal error in during downloading app: &#39; + instanceName)
    

    def getAppName(self, appName):
        &#39;&#39;&#39;
        Description:
        -----------
        Returns the repository name for the corresponding application.

        Parameters:
        ----------
        Job ID : str
            Unique JobID that consists of an uuid and the datetime

        instanceName : str
            The instance name of the application that is used 

        appName : str
            The (github) name of the application that is used 

        version : str
            The wanted version of the application that is used 
        
        Raises:
        -------

        Returns:
        -------
        
        &#39;&#39;&#39;
    
        try:
            url = &#39;https://raw.githubusercontent.com/bibbox/application-store/master/bibboxV4.json&#39;
            download = requests.get(url).content
        except Exception:
            raise Exception(&#39;Something went wrong during connecting to the GitHub repository. Please Check your internet connection!&#39;)
        try:
            params = simplejson.loads(download)
        except Exception:
            bibbox_logger.exception(&#39;Error while loading bibboxV4.json file: &#39;, exc_info=True)
            raise Exception(&#39;Error while loading bibboxV4.json file&#39;)
        appslist=[]
        
        appName = &#39;app-&#39;+appName
        sys.stdout.write(appName+ &#39;\n&#39;)
        
        return appName


    def setInfo(self, jobID, instanceName,appName,version):
        &#39;&#39;&#39;
        Description:
        -----------
        Creates a file named INFO where install information is stored.

        Parameters:
        ----------
        Job ID : str
            Unique JobID that consists of an uuid and the datetime

        instanceName : str
            The instance name of the application that is used 

        appName : str
            The (github) name of the application that is used 

        version : str
            The wanted version of the application that is used 
        
        Raises:
        -------

        Returns:
        -------
        
        &#39;&#39;&#39;

        app_logger, bibbox_logger, docker_logger, app_errorlogger = AppController.setUpLog(self, jobID, instanceName)
        app_logger.info( &#39;Set install info&#39;)
        rootdir = dirname(dirname(abspath(__file__)))
        appPath = rootdir + &#39;/application-instance&#39;
        if path.exists(appPath) == False:
            raise Exception(&#39;The folder &#34;/application-instance&#34; does not exist!&#39;)
    
        data = {}
        data[&#39;instanceName&#39;] = instanceName
        data[&#39;appName&#39;] = appName
        data[&#39;version&#39;] = version
        data[&#39;jobID&#39;] = jobID
        try:
            with open(appPath + &#39;/&#39; + instanceName + &#39;/info.json&#39;, &#39;w+&#39;) as outfile:
                json.dump(data, outfile)
        except Exception:
                app_errorlogger.exception(&#39;Could not open file &#34;info.json&#34; in application folder! &#39;, exc_info=True)
                raise Exception(&#39;Could not open file &#34;info.json&#34; in application folder! &#39;)
        if path.exists(appPath + &#39;/&#39; + instanceName + &#39;/info.json&#39;) == False:
            app_errorlogger.exception(&#39;Something went wrong during writing install information to info.json file of app: &#39; + instanceName, exc_info=True)
            raise Exception(&#39;Fatal error in during writing install information to info.json file of app: &#39; + instanceName)


    def changeInfo(self, jobID, instanceName, newName):
        &#39;&#39;&#39;
        Description:
        -----------
        Creates a file named INFO where install information is stored.

        Parameters:
        ----------
        Job ID : str
            Unique JobID that consists of an uuid and the datetime

        instanceName : str
            The instance name of the application that is used 

        appName : str
            The (github) name of the application that is used 

        version : str
            The wanted version of the application that is used 
        
        Raises:
        -------

        Returns:
        -------
        
        &#39;&#39;&#39;

        app_logger, bibbox_logger, docker_logger, app_errorlogger = AppController.setUpLog(self, jobID, instanceName)
        app_logger.info( &#39;Set install info&#39;)
        rootdir = dirname(dirname(abspath(__file__)))
        appPath = rootdir + &#39;/application-instance&#39;
        if path.exists(appPath) == False:
            raise Exception(&#39;The folder &#34;/application-instance&#34; does not exist!&#39;)
        try:
            with open(appPath + &#39;/&#39; + instanceName + &#39;/info.json&#39;) as outfile:
                data = json.load(outfile)
                data[&#39;instanceName&#39;] = newName
                data[&#39;jobID&#39;] = jobID
        except Exception:
                app_errorlogger.exception(&#39;Could not open file &#34;info.json&#34; in application folder! &#39;, exc_info=True)
                raise Exception(&#39;Could not open file &#34;info.json&#34; in application folder! &#39;)
        try:
            with open(appPath + &#39;/&#39; + newName + &#39;/info.json&#39;, &#39;w+&#39;) as outfile:
                json.dump(data, outfile)
        except Exception:
                app_errorlogger.exception(&#39;Could not open file &#34;info.json&#34; in application folder! &#39;, exc_info=True)
                raise Exception(&#39;Could not write to file &#34;info.json&#34; in application folder! &#39;)


    def setProxyFiles(self, jobID, instanceName, containerName):
        &#39;&#39;&#39;
        Description:
        -----------
        Creates a proxy config file for the nginx web server to use the app container as sub url.

        Parameters:
        ----------
        Job ID : str
            Unique JobID that consists of an uuid and the datetime

        instanceName : str
            The instance name of the application that is used 

        containerName : str
            The name of the container, that is runninng the application 

        
        Raises:
        -------

        Returns:
        -------
        
        &#39;&#39;&#39;

        app_logger, bibbox_logger, docker_logger, app_errorlogger = AppController.setUpLog(self, jobID, instanceName)
        app_logger.info( &#39;Set proxy files&#39;)
        rootdir = dirname(dirname(abspath(__file__)))
        proxyPath = rootdir + &#39;/sys-proxy/&#39;
        if path.exists(proxyPath) == False:
            app_errorlogger.error(&#39;The folder &#34;sys-proxy&#34; does not exist!&#39;)
        if path.exists(proxyPath + &#39;proxyconfig/sites/&#39;) == False:
            process = subprocess.Popen([&#39;mkdir&#39;, proxyPath + &#39;proxyconfig/sites/&#39;])
            output, error = process.communicate()
            if output:
                bibbox_logger.debug( str(output))
        name = instanceName + &#39;.conf&#39;
        
        try:
            with open(proxyPath + &#39;template.conf&#39;) as template:
                file_content = template.read()
                file_content = file_content.replace(&#34;§§INSTANCEID&#34;, instanceName)
                file_content = file_content.replace(&#34;§§CONTAINERNAME&#34;, containerName)
                template = open( proxyPath + &#39;proxyconfig/sites/&#39; + name, &#39;w+&#39;)
                template.write(file_content)
                template.close()
        except Exception:
            app_errorlogger.exception(&#39;Fatal error in writing to proxy template file: &#39;, exc_info=True)
        if path.exists(proxyPath + &#39;proxyconfig/sites/&#39; + name) == False:
            app_errorlogger.exception(&#39;Something went wrong during writing the proxy file for app: &#39; + instanceName, exc_info=True)
            raise Exception(&#39;Fatal error in during writing the proxy file for app: &#39; + instanceName)
        
    def readContainernames(self, jobID, instanceName):
        &#39;&#39;&#39;
        Description:
        -----------
        Reads the container name from the docker-compose-template.yml file.

        Parameters:
        ----------
        Job ID : str
            Unique JobID that consists of an uuid and the datetime

        instanceName : str
            The instance name of the application that is used 
        
        Raises:
        -------

        Returns:
        -------
        ContainerNames: list
            The names of the containers, that are runninng the application
        mainContainer: str
            The name of the main container
        &#39;&#39;&#39;

        app_logger, bibbox_logger, docker_logger, app_errorlogger = AppController.setUpLog(self, jobID, instanceName)
        app_logger.info( &#39;Read Containernames&#39;)
        rootdir = dirname(dirname(abspath(__file__)))
        appPath = rootdir + &#39;/application-instance&#39;
        if path.exists(appPath) == False:
            raise Exception(&#39;The folder &#34;/application-instance&#34; does not exist!&#39;)
        composefile = open(appPath + &#39;/&#39; + instanceName +&#39;/repo/docker-compose-template.yml&#39;, &#39;r&#39;).read()
        try:
            data = yaml.load(composefile, Loader=yaml.FullLoader)
        except Exception:
            app_errorlogger.exception(&#39;Fatal error in loading compose file: &#39;, exc_info=True)
        ContainerNames = []
        try:
            for k, v in data[&#34;services&#34;].items():
                if &#39;container_name&#39; in v:
                    mainContainer = v.get(&#39;container_name&#39;)
                    mainContainer = mainContainer.replace(&#39;§§INSTANCE&#39;, instanceName)
                    try:
                        mainContainer = mainContainer.replace(&#39;-db&#39;, &#39;&#39;)
                    except:
                        pass
                if &#39;container_name&#39; in v:
                    ContainerName = v.get(&#39;container_name&#39;)
                    ContainerName = ContainerName.replace(&#39;§§INSTANCE&#39;, instanceName)
                    ContainerNames.append(ContainerName)
        except Exception:
            app_errorlogger.exception(&#39;Fatal error in reading compose file: &#39;, exc_info=True)

        return ContainerNames, mainContainer

    def writeCompose(self, jobID, paramList, instanceName):
        &#39;&#39;&#39;
        Description:
        -----------
        Changes the instance name of the docker-compose-template.yml file.

        Parameters:
        ----------
        Job ID : str
            Unique JobID that consists of an uuid and the datetime

        paramList: array
            list of environment variables that are defined in the .env file in the repository of the application

        instanceName : str
            The instance name of the application that is used 
        
        Raises:
        -------

        Returns:
        -------
        &#39;&#39;&#39;

        app_logger, bibbox_logger, docker_logger, app_errorlogger = AppController.setUpLog(self, jobID, instanceName)
        app_logger.info(&#39;Write parameters to compose file&#39;)
        rootdir = dirname(dirname(abspath(__file__)))
        appPath = rootdir + &#39;/application-instance/&#39; + instanceName + &#39;/repo/&#39;
        if path.exists(appPath) == False:
            raise Exception(&#39;The folder &#34;/application-instance&#34; does not exist!&#39;)
        try:
            compose = open(appPath + &#39;/docker-compose-template.yml&#39;, &#39;r&#39;).read()
        except Exception:
            app_errorlogger.exception(&#39;Fatal error in reading compose file: &#39;, exc_info=True)

        try:
            for i, key in enumerate(paramList):
                compose = compose.replace(&#39;§§&#39; + key, paramList[key])
        except Exception:
            app_errorlogger.exception(&#39;Fatal error in writing to compose file: &#39;, exc_info=True)
        try:
            compose = compose.replace(&#39;§§INSTANCE&#39;, instanceName)
            target = open(appPath + &#39;/docker-compose-template.yml&#39;, &#39;w&#39;)
            target.write(compose)
            target.close()
        except Exception:
            app_errorlogger.exception(&#39;Fatal error in writing to compose file: &#39;, exc_info=True)



    def writeCLICompose(self, jobID, paramList, keyList, instanceName):
        &#39;&#39;&#39;
        Description:
        -----------
        Changes the instance name of the docker-compose-template.yml file.

        Parameters:
        ----------
        Job ID : str
            Unique JobID that consists of an uuid and the datetime

        paramList: array
            list of environment variables that are defined in the .env file in the repository of the application

        instanceName : str
            The instance name of the application that is used 
        
        Raises:
        -------

        Returns:
        -------
        &#39;&#39;&#39;

        app_logger, bibbox_logger, docker_logger, app_errorlogger = AppController.setUpLog(self, jobID, instanceName)
        app_logger.info(&#39;Write parameters to compose file&#39;)
        rootdir = dirname(dirname(abspath(__file__)))
        appPath = rootdir + &#39;/application-instance/&#39; + instanceName + &#39;/repo/&#39;
        if path.exists(appPath) == False:
            raise Exception(&#39;The folder &#34;/application-instance&#34; does not exist!&#39;)
        try:
            compose = open(appPath + &#39;/docker-compose-template.yml&#39;, &#39;r&#39;).read()
        except Exception:
            app_errorlogger.exception(&#39;Fatal error in reading compose file: &#39;, exc_info=True)
        paramList = re.sub(&#34;[^\w]&#34;, &#34; &#34;, paramList).split()
        
        keyList = re.sub(&#34;[^\w]&#34;, &#34; &#34;, keyList).split()
        
        
        for i, key in enumerate(keyList):
            if key != &#39;&#39;:
                compose = compose.replace(&#39;§§&#39; + key, paramList[i])
        
        
        compose = compose.replace(&#39;§§INSTANCE&#39;, instanceName)
        target = open(appPath + &#39;/docker-compose-template.yml&#39;, &#39;w&#39;)
        target.write(compose)
        target.close()
        


    def composeUp(self, jobID, instanceName, containerName):
        &#39;&#39;&#39;
        Description:
        -----------
        Executes the doker-compose up command and starts the application

        Parameters:
        ----------
        Job ID : str
            Unique JobID that consists of an uuid and the datetime

        instanceName : str
            The instance name of the application that is used 
        
        Raises:
        -------

        Returns:
        -------
        &#39;&#39;&#39;

        app_logger, bibbox_logger, docker_logger, app_errorlogger = AppController.setUpLog(self, jobID, instanceName)
        app_logger.info( &#39;Docker compose up&#39;)
        rootdir = dirname(dirname(abspath(__file__)))
        appPath = rootdir + &#39;/application-instance/&#39; + instanceName + &#39;/repo/&#39;
        if path.exists(appPath) == False:
            raise Exception(&#39;The folder &#34;/application-instance&#34; does not exist!&#39;)
        process = subprocess.Popen([&#39;docker-compose&#39;, &#39;-f&#39;, appPath + &#39;/docker-compose-template.yml&#39;, &#39;up&#39;, &#39;-d&#39;], stdout=subprocess.PIPE, stderr=subprocess.STDOUT, encoding=&#34;utf8&#34;)
        output, error = process.communicate()
        if output:
            docker_logger.error( str(output).rstrip())
        process = subprocess.Popen([&#39;docker&#39;, &#39;exec&#39;, &#39;-it&#39;, &#39;local_nginx&#39;, &#39;service&#39;, &#39;nginx&#39;, &#39;reload&#39;], stdout=subprocess.PIPE, stderr=subprocess.STDOUT, encoding=sys.stdout.encoding)
        output, error = process.communicate()
        ansi_regex = r&#39;\x1b+\[+\d+\d+;+\d+\d+[m]|&#39; \
             r&#39;\x1b(&#39; \
             r&#39;(\[\??\d+[hl])|&#39; \
             r&#39;([=&lt;&gt;a-kzmNM78])|&#39; \
             r&#39;([\(\)][a-b0-2])|&#39; \
             r&#39;(\[\d{0,2}[ma-dgkjqi])|&#39; \
             r&#39;(\[\d+;\d+[hfy]?)|&#39; \
             r&#39;(\[;?[hf])|&#39; \
             r&#39;(#[3-68])|&#39; \
             r&#39;([01356]n)|&#39; \
             r&#39;(O[mlnp-z]?)|&#39; \
             r&#39;(/Z)|&#39; \
             r&#39;(\d+)|&#39; \
             r&#39;(\[\?\d;\d0c)|&#39; \
             r&#39;(\d;\dR)|&#39; \
             r&#39;(\[*\d*\d*;*\d*\d*[m]))&#39; 
             
        ansi_escape = re.compile(ansi_regex, flags=re.IGNORECASE)
        result = ansi_escape.sub(&#39;&#39;, output).rstrip()
        if output:
            bibbox_logger.debug( str(output).rstrip())
        process = subprocess.Popen([&#39;docker&#39;, &#39;logs&#39;, containerName], stdout=subprocess.PIPE, stderr=subprocess.STDOUT, encoding=&#34;utf8&#34;)
        output, error = process.communicate()
        if output:
            docker_logger.debug( str(output).rstrip())
        try:
            process = subprocess.Popen([&#39;docker&#39;, &#39;exec&#39;, containerName, &#39;/var/entrypoint.sh&#39;], stdout=subprocess.PIPE, stderr=subprocess.STDOUT, encoding=&#34;utf8&#34;)
            output, error = process.communicate()
            if output:
                docker_logger.debug( str(output).rstrip())
        except:
            pass

    def stop(self, jobID, instanceName):
        &#39;&#39;&#39;
        Description:
        -----------
        Executes the doker-compose stop command to stop the application

        Parameters:
        ----------
        Job ID : str
            Unique JobID that consists of an uuid and the datetime

        instanceName : str
            The instance name of the application that is used 
        
        Raises:
        -------

        Returns:
        -------
        &#39;&#39;&#39;

        app_logger, bibbox_logger, docker_logger, app_errorlogger = AppController.setUpLog(self, jobID, instanceName)
        app_logger.info( &#39;Stopping App:&#39; + instanceName)
        rootdir = dirname(dirname(abspath(__file__)))
        appPath = rootdir + &#39;/application-instance/&#39; + instanceName + &#39;/repo/&#39;
        if path.exists(appPath) == False:
            app_logger.error(&#39;The folder of the app repository does not exist!&#39;)
        process = subprocess.Popen([&#39;docker-compose&#39;, &#39;-f&#39;, appPath + &#39;/docker-compose-template.yml&#39;, &#39;stop&#39;], stdout=subprocess.PIPE, stderr=subprocess.STDOUT, encoding=&#34;utf8&#34;)
        output, error = process.communicate()
        if output:
            docker_logger.error( str(output).rstrip())

    def start(self, jobID, instanceName):
        &#39;&#39;&#39;
        Description:
        -----------
        Executes the doker-compose start command to start the application

        Parameters:
        ----------
        Job ID : str
            Unique JobID that consists of an uuid and the datetime

        instanceName : str
            The instance name of the application that is used 
        
        Raises:
        -------

        Returns:
        -------
        &#39;&#39;&#39;

        app_logger, bibbox_logger, docker_logger, app_errorlogger = AppController.setUpLog(self, jobID, instanceName)
        app_logger.info( &#39;Starting App:&#39; + instanceName)
        rootdir = dirname(dirname(abspath(__file__)))
        appPath = rootdir + &#39;/application-instance/&#39; + instanceName + &#39;/repo/&#39;
        if path.exists(appPath) == False:
            app_errorlogger.error( &#39; The folder of the app repository does not exist!&#39;)
        process = subprocess.Popen([&#39;docker-compose&#39;, &#39;-f&#39;, appPath + &#39;/docker-compose-template.yml&#39;, &#39;start&#39;], stdout=subprocess.PIPE, stderr=subprocess.STDOUT, encoding=&#34;utf8&#34;)
        output, error = process.communicate()
        if output:
            docker_logger.error( str(output).rstrip())

    def remove(self, jobID, instanceName):
        &#39;&#39;&#39;
        Description:
        -----------
        Executes the doker-compose down command to stop and remove the application

        Parameters:
        ----------
        Job ID : str
            Unique JobID that consists of an uuid and the datetime

        instanceName : str
            The instance name of the application that is used 
        
        Raises:
        -------

        Returns:
        -------
        &#39;&#39;&#39;

        app_logger, bibbox_logger, docker_logger, app_errorlogger = AppController.setUpLog(self, jobID, instanceName)
        app_logger.info( &#39;Removing App:&#39; + instanceName)
        rootdir = dirname(dirname(abspath(__file__)))
        appPath = rootdir + &#39;/application-instance/&#39; + instanceName + &#39;/repo/&#39;
        if path.exists(appPath) == False:
            app_errorlogger.error( &#39;The folder of the app repository does not exist!&#39;)
        process = subprocess.Popen([&#39;docker-compose&#39;, &#39;-f&#39;, appPath + &#39;/docker-compose-template.yml&#39;, &#39;down&#39;], stdout=subprocess.PIPE, stderr=subprocess.STDOUT, encoding=&#34;utf8&#34;)
        output, error = process.communicate()
        if output:
            docker_logger.error( str(output))
        process = subprocess.Popen([&#39;sudo&#39;, &#39;chmod&#39; ,&#39;-f&#39;, &#39;-R&#39;, &#39;777&#39;, rootdir + &#39;/application-instance/&#39; + instanceName], stdout=subprocess.PIPE, stderr=subprocess.STDOUT, encoding=&#34;utf8&#34;)
        output, error = process.communicate()
        if output:
            bibbox_logger.error( str(output))
        process = subprocess.Popen([&#39;rm&#39; , &#39;-f&#39;, &#39;-R&#39;, rootdir + &#39;/application-instance/&#39; + instanceName], stdout=subprocess.PIPE, stderr=subprocess.STDOUT, encoding=&#34;utf8&#34;)
        output, error = process.communicate()
        if output:
            bibbox_logger.error( str(output))
        process = subprocess.Popen([&#39;rm&#39; , &#39;-f&#39;, rootdir + &#39;/sys-proxy/proxyconfig/sites/&#39; + instanceName + &#39;.conf&#39;], stdout=subprocess.PIPE, stderr=subprocess.STDOUT, encoding=&#34;utf8&#34;)
        output, error = process.communicate()
        if output:
            bibbox_logger.error( str(output))

    def status(self, jobID, instanceName):
        &#39;&#39;&#39;
        Description:
        -----------
        Reads the file STATUS to get the currend state of an application

        Parameters:
        ----------
        Job ID : str
            Unique JobID that consists of an uuid and the datetime

        instanceName : str
            The instance name of the application that is used 
        
        Raises:
        -------

        Returns:
        -------
        status: str
            The current status of an application
        &#39;&#39;&#39;

        app_logger, bibbox_logger, docker_logger, app_errorlogger = AppController.setUpLog(self, jobID, instanceName)
        app_logger.info( &#39;Reading Status of App: &#39; + instanceName)
        rootdir = dirname(dirname(abspath(__file__)))
        appPath = rootdir + &#39;/application-instance/&#39; + instanceName + &#39;/&#39;
        if path.exists(appPath) == False:
            app_errorlogger.error( &#39; The folder of the app repository does not exist!&#39;)
        try:
            with open(appPath + &#39;STATUS&#39;) as statusfile:
                file_content = statusfile.read()
        except Exception:
            app_errorlogger.exception(&#39;Could not open STATUS file: &#39;, exc_info=True)
        return file_content

    def checkStatus(self, jobID, instanceName, statusList):
        &#39;&#39;&#39;
        Description:
        -----------
        Reads the file STATUS to get the currend state of an application and checks, if the status is allowed for the wanted operation.

        Parameters:
        ----------
        Job ID : str
            Unique JobID that consists of an uuid and the datetime

        instanceName : str
            The instance name of the application that is used 

        statusList: array
            List of states, that allow a specific operation on an application
        
        Raises:
        -------
        raise Exception(&#39;Current app status does not allow your operation!&#39;) if the currend status is not in the statuslist

        Returns:
        -------
        
        &#39;&#39;&#39;

        app_logger, bibbox_logger, docker_logger, app_errorlogger = AppController.setUpLog(self, jobID, instanceName)
        app_logger.info( &#39;Checking if operation is possible for current state of app: &#39; + instanceName)
        rootdir = dirname(dirname(abspath(__file__)))
        appPath = rootdir + &#39;/application-instance/&#39; + instanceName + &#39;/&#39;
        if path.exists(appPath) == False:
            app_errorlogger.debug(&#39;The folder of the app repository does not exist!&#39;)
        try:
            with open(appPath + &#39;STATUS&#39;) as statusfile:
                file_content = statusfile.read()
                
        except Exception:
            logging.exception(&#39;Could not open STATUS file: &#39;, exc_info=True)
        if file_content not in statusList:
            app_errorlogger.exception(&#39;Current app status does not allow operation on app: &#39; + instanceName)
            raise Exception(&#39;Current app status does not allow your operation!&#39;)

    def copy(self, jobID, instanceName, newName):
        &#39;&#39;&#39;
        Description:
        -----------
        Copies the current app folder to the new app destination.

        Parameters:
        ----------
        Job ID : str
            Unique JobID that consists of an uuid and the datetime

        instanceName: str
            The instance name of the application that is used 

        newName: str
            New name of the copied application
        
        Raises:
        -------

        Returns:
        -------
        
        &#39;&#39;&#39;

        app_logger, bibbox_logger, docker_logger,  app_errorlogger = AppController.setUpLog(self, jobID, instanceName)
        app_logger.info(&#39;Copy App:&#39; + instanceName)
        rootdir = dirname(dirname(abspath(__file__)))
        appPath = rootdir + &#39;/application-instance/&#39; + instanceName + &#39;/repo/&#39;
        if path.exists(appPath) == False:
            app_errorlogger.error(&#39;The folder of the app repository does not exist!&#39;)
        process = subprocess.Popen([&#39;sudo&#39;, &#39;chmod&#39;, &#39;-R&#39;, &#39;777&#39;, rootdir + &#39;/application-instance/&#39; +  instanceName], stdout=subprocess.PIPE, stderr=subprocess.STDOUT)
        output, error = process.communicate()
        if output:
            app_errorlogger.error( str(output))
        process = subprocess.Popen([&#39;cp&#39;, &#39;-r&#39;, rootdir + &#39;/application-instance/&#39; + instanceName, rootdir + &#39;/application-instance/&#39; + newName], stdout=subprocess.PIPE, stderr=subprocess.STDOUT)
        output, error = process.communicate()
        if output:
            app_errorlogger.error( str(output))
        

    def changeCompose(self, jobID, instanceName, newName):
        &#39;&#39;&#39;
        Description:
        -----------
        Reads the file STATUS to get the currend state of an application and checks, if the status is allowed for the wanted operation.

        Parameters:
        ----------
        Job ID : str
            Unique JobID that consists of an uuid and the datetime

        paramList: array
            list of environment variables that are defined in the .env file in the repository of the application

        instanceName : str
            The instance name of the application that is used 

        newName: str
            new instance name name of copied application
        
        Raises:
        -------

        Returns:
        -------
        
        &#39;&#39;&#39;

        app_logger, bibbox_logger, docker_logger, app_errorlogger = AppController.setUpLog(self, jobID, instanceName)
        app_logger.info( &#39;Write parameters to compose file&#39;)
        rootdir = dirname(dirname(abspath(__file__)))
        appPath = rootdir + &#39;/application-instance/&#39; + instanceName + &#39;/repo/&#39;
        if path.exists(appPath) == False:
            app_errorlogger.error(&#39; The folder of the app repository does not exist!&#39;)
        newAppPath = rootdir + &#39;/application-instance/&#39; + newName + &#39;/repo/&#39;
        try:
            compose = open(appPath + &#39;/docker-compose-template.yml&#39;, &#39;r&#39;)
        except Exception:
            app_errorlogger.exception(&#39;Fatal error in reading compose file: &#39;, exc_info=True)
        try:
            compose = yaml.load(compose)
            services = compose[&#39;services&#39;]
        except Exception:
            app_errorlogger.exception(&#39;Fatal error in reading compose file: &#39;, exc_info=True)
        try:
            for service in services:
                name = services[service][&#39;container_name&#39;]
                newContainerName = name.replace(instanceName, newName)
                services[service][&#39;container_name&#39;] = newContainerName
                try:
                    name = services[service][&#39;links&#39;]
                    newContainerName = name[0].replace(instanceName, newName)
                    services[service][&#39;links&#39;] = [newContainerName]
                except:
                    pass
                try:
                    name = services[service][&#39;depends_on&#39;]
                    newContainerName = name[0].replace(instanceName, newName)
                    services[service][&#39;depends_on&#39;] = [newContainerName]
                except:
                    pass
        except Exception:
            app_errorlogger.exception(&#39;Fatal error in reading compose file: &#39;, exc_info=True)
        try:    
            composenew = copy.deepcopy(compose)
        except Exception:
            app_errorlogger.exception(&#39;Fatal error while copying compose file: &#39;, exc_info=True)
        try:
            for service in services:
                newServiceName = service.replace(instanceName, newName)           
                composenew[&#39;services&#39;][newServiceName] = composenew[&#39;services&#39;][service]
                del composenew[&#39;services&#39;][service]
        except Exception:
            app_errorlogger.exception(&#39;Fatal error while writing to compose file: &#39;, exc_info=True)
        try:
            composefile = yaml.dump(composenew)
            os.system(&#39;sudo chmod -R 777 &#39; + newAppPath)
            target = open(newAppPath + &#39;docker-compose-template.yml&#39;, &#39;w&#39;)
            target.write(composefile)
            target.close()
        except Exception:
            app_errorlogger.exception(&#39;Fatal error while writing to compose file: &#39;, exc_info=True)

    def readVersion(self, jobID, appName):
        &#39;&#39;&#39;
        Description:
        -----------
        Lists the available Apps.

        Parameters:
        ----------

        Raises:
        -------

        Returns:
        -------
        appslist: json object
            The list of all available apps as json object
        &#39;&#39;&#39;

        try:
            url = &#39;https://raw.githubusercontent.com/bibbox/application-store/master/eB3Kit.json&#39;
            download = requests.get(url).content
        except Exception:
            raise Exception(&#39;Something went wrong during connecting to the GitHub repository. Please Check your internet connection!&#39;)
        try:
            params = simplejson.loads(download)
        except Exception:
            #app_errorlogger.exception(&#39;Error while loading eB3Kit.json file: &#39;, exc_info=True)
            raise Exception(&#39;Error while loading eB3Kit.json file&#39;)
        versionList=[]
        try:
            for i, values in enumerate(params):
                variable = values[&#39;group_members&#39;]
                for i, var in enumerate(variable):
                    if var[&#39;app_name&#39;] == appName:
                        versions = var[&#39;versions&#39;]
                        for version in versions:
                            versionList.append(version[&#39;docker_version&#39;])
                    if var[&#39;app_display_name&#39;] == appName:
                        versions = var[&#39;versions&#39;]
                        for version in versions:
                            versionList.append(version[&#39;docker_version&#39;])
        except:
            raise Exception(&#39;The wanted app does not exist. Please check the list of available apps!&#39;)                

        return versionList

    def readAppStore(self, jobID, instanceName):
        &#39;&#39;&#39;
        Description:
        -----------
        Lists the available Apps.

        Parameters:
        ----------

        Raises:
        -------

        Returns:
        -------
        appslist: json object
            The list of all available apps as json object
        &#39;&#39;&#39;
        bibbox_logger = AppController.setUpLog(self, jobID, &#39;system&#39;, systemonly=True)
        try:
            url = &#39;https://raw.githubusercontent.com/bibbox/application-store/master/eB3Kit.json&#39;
            download = requests.get(url).content
        except Exception:
            raise Exception(&#39;Something went wrong during connecting to the GitHub repository. Please Check your internet connection!&#39;)
        try:
            params = simplejson.loads(download)
        except Exception:
            bibbox_logger.exception(&#39;Error while loading eB3Kit.json file: &#39;, exc_info=True)
            raise Exception(&#39;Error while loading eB3Kit.json file&#39;)
        appslist=[]
        try:
            for i, values in enumerate(params):
                variable = values[&#39;group_members&#39;]
                for i, var in enumerate(variable):
                    appName = var[&#39;app_name&#39;]
                    if appName not in appslist:
                        appslist.append(appName)
        except Exception:
            raise Exception(&#39;Error while loading eB3Kit.json file!&#39;)
            bibbox_logger.exception(&#39;Error while loading eB3Kit.json file: &#39;, exc_info=True)                

        return appslist
        


    def getInstalledApps(self, jobID, instanceName):
        &#39;&#39;&#39;
        Description:
        -----------
        Lists the available Apps.

        Parameters:
        ----------

        Raises:
        -------

        Returns:
        -------
        installedAppslist: json object
            The list of all installed apps as json object
        &#39;&#39;&#39;

        bibbox_logger = AppController.setUpLog(self, jobID, instanceName, systemonly=True)
        rootdir = dirname(dirname(abspath(__file__)))
        appPath = rootdir + &#39;/application-instance/&#39; 
        if path.exists(appPath) == False:
            app_erbibbox_loggerrorlogger.error(&#39; The folder of the app repository does not exist!&#39;)
        installedApps = {}
        try:
            for i, folder in enumerate(os.listdir(appPath)):
                with open(appPath + &#39;/&#39; + folder + &#39;/info.json&#39;) as infofile:
                    data = json.load(infofile)
                    instanceName = data[&#39;instanceName&#39;]
                    appName = data[&#39;appName&#39;]
                    installedApps[instanceName] = appName
        except Exception:
                bibbox_logger.exception(&#39;Could not open file &#34;info.json&#34; in application folder! &#39;, exc_info=True)
                raise Exception(&#39;Could not open file &#34;info.json&#34; in application folder! &#39;)
                
                
        installedAppsList = json.dumps(installedApps)
        return installedAppsList

    def checkDockerState(self, jobID, instanceName, containerNames, allowedStates):
        &#39;&#39;&#39;
        Description:
        -----------
        Ckecks the states of all containers of an app.

        Parameters:
        ----------

        jobID : str
            Unique JobID that consists of an uuid and the datetime

        instanceName : str
            The instance name of the application that is used 

        containerNames: array
            list of used containers
        
        Raises:
        -------

        Returns:
        -------
        
        &#39;&#39;&#39;
        app_logger, bibbox_logger, docker_logger, app_errorlogger = AppController.setUpLog(self, jobID, instanceName)
        app_logger.info(&#39;Checking states of all containers of app: &#39; + instanceName)
        states = {}
        for name in containerNames:
            process = subprocess.Popen([&#39;docker&#39;, &#39;container&#39;, &#39;inspect&#39;, name], stdout=subprocess.PIPE, stderr=subprocess.STDOUT)
            output, error = process.communicate()
            try:
                params = simplejson.loads(output)
                status = params[0][&#39;State&#39;][&#39;Status&#39;]
                states[name] = status
            except Exception:
                app_errorlogger.exception(&#39;Could not load status of wanted container. &#39; + name + &#39; Maybe this container got removed manually. Please look at the log files!&#39;, exc_info=True)
                raise Exception(&#39;Could not load status of wanted container &#39; + name + &#39; Maybe this container got removed manually. Please look at the log files!&#39;)
            if &#39;all&#39; in allowedStates:
                pass
            else:
                if status not in allowedStates:
                    app_errorlogger.error(&#39;Could not perform the wanted task. The allowed states of the app containers are: &#34;&#39; + &#39;, &#39;.join([str(elem) for elem in allowedStates]) + &#39;&#34;. But the container of app &#39; + instanceName + &#39; has state &#39; + status + &#39;.&#39;)
                    raise Exception(&#39;Could not perform the wanted task. The allowed states of the app containers are: &#39; + &#39;, &#34;&#39;.join([str(elem) for elem in allowedStates]) + &#39;&#34;. But the container of app &#39; + instanceName + &#39; has state &#39; + status + &#39;.&#39;)

        return states

    def checkProxy(self, containerName):
        &#39;&#39;&#39;
        Description:
        -----------
        Ckecks the state of the proxy container.

        Parameters:
        ----------

        containerNames: array
            list of used containers
        
        Raises:
        -------

        Returns:
        -------
        
        &#39;&#39;&#39;
        bibbox_logger = AppController.setUpLog(self, &#39;system check&#39;, &#39;system &#39;, systemonly=True)
        bibbox_logger.info(&#39;Performing proxy check!&#39;)
        states = {}
        process = subprocess.Popen([&#39;docker&#39;, &#39;container&#39;, &#39;inspect&#39;, containerName], stdout=subprocess.PIPE, stderr=subprocess.STDOUT)
        output, error = process.communicate()
        state = &#39;&#39;
        try:
            params = simplejson.loads(output)
            state = params[0][&#39;State&#39;][&#39;Status&#39;]
        
            
            if state == &#39;running&#39;:
                 bibbox_logger.info(&#39;The nginx Container is running. \n Everything OK.&#39;)
            else:
                 bibbox_logger.error(&#39;The nginx Container is not running. \n Please try to restart the bibbox System.&#39;)
        except:
             bibbox_logger.error(&#39;The nginx Container is not running. \n Please try to restart the bibbox System with &#34;bibbox restartSystem&#34;.&#39;)

        return state

    def checkSystem(self):
        &#39;&#39;&#39;
        Description:
        -----------
        System Check. Checks the versions of the required packages.

        Parameters:
        ----------

        containerNames: array
            list of used containers
        
        Raises:
        -------

        Returns:
        -------
        
        &#39;&#39;&#39;

        bibbox_logger = AppController.setUpLog(self, &#39;system check&#39;, &#39;system &#39;, systemonly=True)
        bibbox_logger.info(&#39;Performing system check!&#39;)

        if float(str(sys.version_info[0]) + &#39;.&#39; + str(sys.version_info[1])) &gt; 3.5:
            bibbox_logger.info(&#39;Python Version: &#39; + str(sys.version_info[0]) + &#39;.&#39; + str(sys.version_info[1]) + &#39; ---&gt; OK!&#39;)
        else:
            bibbox_logger.error(&#39;You are using a Python version below 3.5 or do not have Python installed. Please install Python 3.5+!&#39;)
            bibbox_logger.error(output)

        process = subprocess.Popen([&#39;docker&#39;, &#39;version&#39;, &#39;--format&#39;, &#39;{{.Server.Version}}&#39;], stdout=subprocess.PIPE, stderr=subprocess.STDOUT)
        output, error = process.communicate()
        output = output.decode(&#39;utf-8&#39;)
        if version.parse(output) &gt; version.parse(&#34;19.03.00&#34;):
            bibbox_logger.info(&#39;Docker Version: &#39; + output + &#39; ---&gt; OK!&#39;)
        else:
            bibbox_logger.error(&#39;You are using a Docker Engine version below 19.03.0 or do not have Docker Engine installed. Please install Docker Engine 19.03.0+!&#39;)
            bibbox_logger.error(output)

        process = subprocess.Popen([&#39;docker-compose&#39;, &#39;version&#39;,  &#39;--short&#39;], stdout=subprocess.PIPE, stderr=subprocess.STDOUT)
        output, error = process.communicate()
        output = output.decode(&#39;utf8&#39;)
        
        if version.parse(str(output)) &gt; version.parse(&#34;1.26.0&#34;):
            bibbox_logger.info(&#39;Docker-Compose Version: &#39; + output + &#39; ---&gt;  OK!&#39;)
        else:
            bibbox_logger.error(&#39;You are using a Docker Compose version below 1.26.0 or do not have Docker Compose installed. Please install Docker Compose 1.26.0+!&#39;)
            bibbox_logger.error(output)

        process = subprocess.Popen([&#39;docker&#39;, &#39;network&#39;, &#39;create&#39;, &#39;bibbox-default-network&#39;], stdout=subprocess.PIPE, stderr=subprocess.STDOUT)
        output, error = process.communicate()
        output = output.decode(&#39;utf8&#39;)
        if output:
            bibbox_logger.debug(&#39;Creating default network:&#39; + output)

        bibbox_logger.info(&#39;Check internet connection&#39;)
        try:
            requests.get(&#39;http://216.58.192.142&#39;, timeout=1)
            bibbox_logger.debug(&#39;Internet connection ---&gt; OK&#39;)
        except: 
            bibbox_logger.error(&#39;Can not connect to the internet!&#39;)

    def checkInput(self, jobID, instanceName, inputparams):
        &#39;&#39;&#39;
        Description:
        -----------
        Ckecks if the userinput is valid.

        Parameters:
        ----------

        jobID : str
            Unique JobID that consists of an uuid and the datetime

        instanceName : str
            The instance name of the application that is used 

        input: array
            List of used parameters to check
        
        Raises:
        -------

        Returns:
        -------
        
        &#39;&#39;&#39;
        bibbox_logger = AppController.setUpLog(self, jobID, instanceName, systemonly = True)
        if type(instanceName) != str:
            bibbox_logger.debug(&#39;The input &#39; + instanceName + &#39; is not valid! Must be a string, but has type &#39; + type(instanceName) + &#39;!&#39;)
        validAll = True
        if not inputparams:
            bibbox_logger.info(&#39;There are no input parameters to check&#39;)
        for var in inputparams:
            valid = bool(re.match(&#39;^[a-zA-Z0-9\-]*$&#39;,var))
            negativeList = [&#39;admin&#39;]
            for param in negativeList:
                if param in var:
                    validAll = False
                    bibbox_logger.debug(&#39;The input &#39; + var + &#39; is not valid!&#39;)
            if valid == False:
                validAll = False
                bibbox_logger.debug(&#39;The input &#39; + var + &#39; is not valid!&#39;)

        if validAll == True:
            bibbox_logger.debug(&#39;The tested input is valid!&#39;)
        if validAll == False:
            bibbox_logger.debug(&#39;The tested input is not valid!&#39;)

        return validAll

    def checkInstall(self, jobID, instanceName, states):
        &#39;&#39;&#39;
        Description:
        -----------
        After the installation of an app, this function checks if the installation was sucessfull and the app is running.

        Parameters:
        ----------

        jobID : str
            Unique JobID that consists of an uuid and the datetime

        instanceName : str
            The instance name of the application that is used 

        states: json Object
            List of installed containers and their corresponding state
        
        Raises:
        -------

        Returns:
        -------
        
        &#39;&#39;&#39;
        app_logger, bibbox_logger, docker_logger, app_errorlogger = AppController.setUpLog(self, jobID, instanceName)
        app_logger.info(&#39;Checking if installation of app &#39; + instanceName + &#39; was successful!&#39;)
        for container in states:
            state = states[container]
            if state != &#39;running&#39;:
                try: 
                    AppController.startApp(self, instanceName)
                except:
                    pass
            if state != &#39;running&#39;:
                AppController.removeApp(self, instancename)
                app_logger.error(&#39;The installation could not be completed. Please read the logs and try again&#39;)

    def startNginx(self, JobID):
        &#39;&#39;&#39;
        Description:
        -----------
        Starts the nginx proxy of the bibbox system.

        Parameters:
        ----------

        jobID : str
            Unique JobID that consists of an uuid and the datetime

        
        Raises:
        -------

        Returns:
        -------
        
        &#39;&#39;&#39;
        bibbox_logger = AppController.setUpLog(self, JobID, &#39;system&#39;, systemonly=True)
        bibbox_logger.info(&#39;Starting nginx container&#39;)
        
        process = subprocess.Popen([&#39;docker-compose&#39;,&#39;-f&#39;, &#39;/opt/bibbox/sys-bibbox/docker-compose.yml&#39;, &#39;up&#39;, &#39;-d&#39;], stdout=subprocess.PIPE, stderr=subprocess.STDOUT)
        output, error = process.communicate()
        if output:
            output = output.decode(&#39;utf8&#39;)
            output = output.strip()
            bibbox_logger.error(output)

    def stopNginx(self, JobID):
        &#39;&#39;&#39;
        Description:
        -----------
        Stops the nginx proxy of the bibbox system.

        Parameters:
        ----------

        jobID : str
            Unique JobID that consists of an uuid and the datetime

        
        Raises:
        -------

        Returns:
        -------
        
        &#39;&#39;&#39;
        bibbox_logger = AppController.setUpLog(self, JobID, &#39;system&#39;, systemonly=True)
        bibbox_logger.info(&#39;Stopping nginx container&#39;)
        
        process = subprocess.Popen([&#39;docker-compose&#39;,&#39;-f&#39;, &#39;/opt/bibbox/sys-bibbox/docker-compose.yml&#39;, &#39;down&#39;], stdout=subprocess.PIPE, stderr=subprocess.STDOUT)
        output, error = process.communicate()
        if output:
            output = output.decode(&#39;utf8&#39;)
            output = output.strip()
            bibbox_logger.error(output)


    


    def getParams(self, instanceName, appName, version):
        &#39;&#39;&#39;
        Description:
        -----------
        Reads the user parameters of an app.

        Parameters:
        ----------

        instanceName : str
            The instance name of the application that is used 

        appName: str
            Name of the wanted app

        version: str
            Version of the wanted app
        
        Raises:
        -------

        Returns:
        -------
        paramList: array
            List of all userparameters
        
        &#39;&#39;&#39;
        try:
            url = &#39;https://raw.githubusercontent.com/bibbox/&#39; + appName + &#39;/master/.env&#39;
            download = requests.get(url).content
        except Exception:
            raise Exception(&#39;Something went wrong during connecting to the GitHub repository. Please Check your internet connection!&#39;)
        data=download.decode(&#39;utf-8&#39;)
        params = data.split(&#39;\n&#39;)
        paramList = {}
        for line in params:
            params = line.split(&#39;=&#39;)
            param = params[0]
            if param == &#39;PORT&#39; or param == &#39;&#39; or param == &#39;INSTANCE&#39;:
                pass
            else:
                paramList[param] = []
            
        return paramList, instanceName, appName, version

    def setParams(self, paramList):
        &#39;&#39;&#39;
        Description:
        -----------
        Reads the user parameters of an app.

        Parameters:
        ----------
        paramList: array
            List of all userparameters

        Raises:
        -------

        Returns:
        -------
        &#39;&#39;&#39;
        for key in paramList:
            paramList[key] = &#39;seeddms&#39;

        return paramList


    def changeSettings(self, jobID, instanceName):
        &#39;&#39;&#39;
        Description:
        -----------
        Looks for config files of an app and changes them to use the app container as sub url.

        Parameters:
        ----------
        Job ID : str
            Unique JobID that consists of an uuid and the datetime

        instanceName : str
            The instance name of the application that is used 


        
        Raises:
        -------

        Returns:
        -------
        
        &#39;&#39;&#39;

        app_logger, bibbox_logger, docker_logger, app_errorlogger = AppController.setUpLog(self, jobID, instanceName)
        app_logger.info( &#39;Change setting files&#39;)
        rootdir = dirname(dirname(abspath(__file__)))
        settingsPath = rootdir + &#39;/application-instance/&#39; + instanceName + &#39;/repo/config/&#39;
        if path.exists(settingsPath) == True:
            for filename in os.listdir(settingsPath):
                try:
                    with open(settingsPath + filename) as template:
                        file_content = template.read()
                        file_content = file_content.replace(&#34;§§INSTANCENAME&#34;, instanceName)    
                        template = open( settingsPath + filename, &#39;w+&#39;)
                        template.write(file_content)
                        template.close()
                except:
                    pass

        entrypointPath = rootdir + &#39;/application-instance/&#39; + instanceName + &#39;/repo/entrypoint.sh&#39;

        try:
            with open(entrypointPath) as template:
                file_content = template.read()
                file_content = file_content.replace(&#34;§§INSTANCENAME&#34;, instanceName)
                template = open( entrypointPath, &#39;w+&#39;)
                template.write(file_content)
                template.close()
        except Exception:
            pass
        
            </code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="helperFunctions.AppController"><code class="flex name class">
<span>class <span class="ident">AppController</span></span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class AppController:

    def __init__(self):
        self.rootdir = dirname(dirname(abspath(__file__)))
        self.appPath = self.rootdir + &#39;/application-instance&#39;
        with open(self.rootdir + &#39;/environment-parameters.json&#39;) as infofile:
            params = json.load(infofile)
            domain = params[0][&#39;DOMAIN_NAME&#39;]
        
    def __del__(self):
        try:
            jobID = AppController.createJobID(self)
            instanceName = self.instanceName
            AppController.unlock(self, jobID, instanceName, end = True)
        except:
            pass

    def createJobID(self):
        &#39;&#39;&#39;
        Description:
        -----------
        Creates a unique JobID to be able to identify every single job.

        Parameters:
        ----------

        Raises:
        -------
        
        Returns:
        -------
        Job ID : str
            Unique JobID that consists of an uuid and the current datetime
        &#39;&#39;&#39;
        jobID = str(uuid.uuid1())
        dateObj = datetime.now()
        datestring = str(dateObj.year) + &#39;-&#39; + str(dateObj.month) + &#39;-&#39; + str(dateObj.day) + &#39;-&#39; + str(dateObj.microsecond)
        jobID = jobID + datestring
        return jobID

    def checkExists(self, jobID, instanceName, install):
        &#39;&#39;&#39;
        Description:
        -----------
        Checks if an app with the wanted name does already exist.

        Parameters:
        ----------
        Job ID : str
            Unique JobID that consists of an uuid and the datetime

        instanceName : str
            The instance name of the application that is used 

        install: bool
            Is the method performed during Installation?
            For installation, its necessary that the app does not exist, 
            but for start, stop, coppy ... of an app it is important that the app already exists.

        Raises:
        -------
        if install == True:

            if exists == True

                raise Exception(&#39;The app you want to install does already exist!&#39;)

        if install == False:

            if exists == False:

                raise Exception(&#39;The app you want to use does not exist!&#39;)

        Returns:
        -------
        
        &#39;&#39;&#39;
        rootdir = dirname(dirname(abspath(__file__)))
        bibbox_logger = AppController.setUpLog(self, jobID, instanceName, systemonly=True)
        appPath = rootdir + &#39;/application-instance/&#39;
        bibbox_logger.info(&#39;Check if app folder exists&#39;)
        if path.exists(appPath) == False:
            process = subprocess.Popen([&#39;mkdir&#39;, appPath])
            output, error = process.communicate()
            if output:
                bibbox_logger.debug( str(output))
        if instanceName in os.listdir(appPath):
            exists = True
        else:
            exists = False
        if install == True:
            if exists == True:
                bibbox_logger.info(&#39;The app you want to install does already exist! App: &#39; + instanceName)
                raise Exception(&#39;The app you want to install does already exist! App: &#39; + instanceName)
        if install == False:
            if exists == False:
                bibbox_logger.info(&#39;The app you want to use does not exist! App: &#39; + instanceName)
                raise Exception(&#39;The app you want to use does not exist! App: &#39; + instanceName)

    def createFolder(self, jobID, instanceName):
        &#39;&#39;&#39;
        Description:
        -----------
        Creates destination folder for app repository.

        Parameters:
        ----------
        Job ID : str
            Unique JobID that consists of an uuid and the datetime

        instanceName : str
            The instance name of the application that is used 
        
        Raises:
        -------
        

        Returns:
        -------
        
        &#39;&#39;&#39;
        bibbox_logger = AppController.setUpLog(self, jobID, instanceName, systemonly=True)
        bibbox_logger.info(&#39;Check if app folder exists&#39;)
        rootdir = dirname(dirname(abspath(__file__)))
        appPath = rootdir + &#39;/application-instance&#39;
        if path.exists(appPath) == False:
            bibbox_logger.error( &#39;Error While creating folder for application &#39; + instanceName + &#39;. The folder &#34;/application-instance&#34; does not exist!&#39;)
            raise Exception(&#39;Error While creating folder for application &#39; + instanceName + &#39;. The folder &#34;/application-instance&#34; does not exist!&#39;)
        process = subprocess.Popen([&#39;mkdir&#39; , appPath + &#39;/&#39; + instanceName])
        output, error = process.communicate()
        if output:
            bibbox_logger.debug( str(output))
        process = subprocess.Popen([&#39;mkdir&#39; , appPath + &#39;/&#39; + instanceName + &#39;/log/&#39;])
        output, error = process.communicate()
        if output:
            bibbox_logger.debug( str(output))
        if path.exists(appPath + &#39;/&#39; + instanceName) == False:
            bibbox_logger.error( &#39;Error While creating folder for application &#39; + instanceName + &#39;. The folder &#34;/application-instance/&#39; + instanceName + &#39;/&#34; does not exist!&#39;)
            raise Exception(&#39;Error While creating folder for application &#39; + instanceName + &#39;. The folder &#34;/application-instance&#34; does not exist!&#39;)
        if path.exists(appPath + &#39;/&#39; + instanceName + &#39;/log/&#39;) == False:
            bibbox_logger.error( &#39;Error While creating folder for application &#39; + instanceName + &#39;. The folder &#34;/application-instance&#39; + instanceName + &#39;/log/&#34; does not exist!&#39;)
            raise Exception(&#39;Error While creating folder for application &#39; + instanceName + &#39;. The folder &#34;/application-instance&#34; does not exist!&#39;)

    def setup_logger(self, jobID, loggerName, log_file, level=logging.DEBUG):
        &#39;&#39;&#39;
        Description:
        -----------
        Sets up logger.

        Parameters:
        ----------
        Job ID : str
            Unique JobID that consists of an uuid and the datetime

        loggerName : str
            Name of the logger 

        logfile : str
            Path like object that defines the logfile destination and the logfile&#39;s name
        
        Raises:
        -------
        

        Returns:
        -------
        
        &#39;&#39;&#39;
        
        formatter = logging.Formatter(&#39;%(asctime)s - %(levelname)s - %(name)s - %(message)s&#39;)
        logformatter = logging.Formatter(jobID + &#39;%(asctime)s - %(levelname)s - %(name)s - %(message)s&#39;)
        logger = logging.getLogger(loggerName)
        if logger.handlers[:] == []:
            handler = logging.handlers.RotatingFileHandler(log_file, maxBytes=20000000, backupCount = 10)
            handler.setFormatter(logformatter)
            stream = logging.StreamHandler()
            stream.setFormatter(formatter)
            logger.addHandler(stream)
            logger.addHandler(handler)
        logger.setLevel(level)

        return logger
    
    def setUpLog(self, jobID, instanceName, systemonly = False):
        &#39;&#39;&#39;
        Description:
        -----------
        Sets up initial log settings, such as format, file name etc.

        Parameters:
        ----------
        Job ID : str
            Unique JobID that consists of an uuid and the datetime

        instanceName : str
            The instance name of the application that is used 
        
        Raises:
        -------
        

        Returns:
        -------
        
        &#39;&#39;&#39;
        rootdir = dirname(dirname(abspath(__file__)))
        if systemonly == False:
            appPath = rootdir + &#39;/application-instance&#39;
            if path.exists(appPath) == False:
                raise Exception( &#39; - The folder &#34;/application-instance/&#34; does not exist!&#39;)
            logpath = appPath + &#39;/&#39; + instanceName + &#39;/log/&#39;
            if path.exists(logpath) == False:
                raise Exception( &#39; - The folder &#34;/application-instance/&#39; + instanceName + &#39;/log/&#34; does not exist!&#39;)
            app_logger = AppController.setup_logger(self, jobID, instanceName + &#39;-app.log&#39;, logpath + &#39;debug.log&#39;, level=logging.DEBUG)
            app_errorlogger = AppController.setup_logger(self, jobID, instanceName + &#39;-apperror.log&#39;, logpath + &#39;error.log&#39;, level=logging.DEBUG)
            docker_logger = AppController.setup_logger(self, jobID, instanceName + &#39;-docker.log&#39;, logpath + &#39;docker.log&#39;, level=logging.DEBUG)
            bibbox_logger = AppController.setup_logger(self, jobID, instanceName + &#39;-bibbox.log&#39;, rootdir + &#39;/log/system.log&#39;, level=logging.DEBUG)
            
            if path.exists(logpath + &#39;debug.log&#39;) == False:
                raise Exception(&#39;Error while creating logfile &#34;debug.log&#34; in folder &#39; + logpath + &#39;.&#39;)
            if path.exists(logpath + &#39;error.log&#39;) == False:
                raise Exception(&#39;Error while creating logfile &#34;error.log&#34; in folder &#39; + logpath + &#39;.&#39;)
            if path.exists(logpath + &#39;docker.log&#39;) == False:
                raise Exception(&#39;Error while creating logfile &#34;docker.log&#34; in folder &#39; + logpath + &#39;.&#39;)
            if path.exists(rootdir + &#39;/log/system.log&#39;) == False:
                raise Exception(&#39;Error while creating logfile &#34;system.log&#34; in folder &#39; + logpath + &#39;.&#39;)
            
            return app_logger, bibbox_logger, docker_logger, app_errorlogger
        else:
            bibbox_logger = AppController.setup_logger(self, jobID, instanceName + &#39;bibbox&#39;, rootdir + &#39;/log/system.log&#39;, level=logging.DEBUG)
            if path.exists(rootdir + &#39;/log/system.log&#39;) == False:
                raise Exception(&#39;Error while creating logfile &#34;system.log&#34;&#39;)
            
            return bibbox_logger

    
    def setStatus(self, jobID, status, instanceName):
        &#39;&#39;&#39;
        Description:
        -----------
        Sets the current ststus of an app and writes it to a file calles STATUS.

        Parameters:
        ----------
        Job ID : str
            Unique JobID that consists of an uuid and the datetime

        status: str
            The wanted ststus that gets written to the STATUS file

        instanceName : str
            The instance name of the application that is used 
        
        Raises:
        -------
        

        Returns:
        -------
        
        &#39;&#39;&#39;

        app_logger, bibbox_logger, docker_logger, app_errorlogger = AppController.setUpLog(self, jobID, instanceName)
        app_logger.info(&#39;Set status to &#39; + status )
        rootdir = dirname(dirname(abspath(__file__)))
        appPath = rootdir + &#39;/application-instance&#39;
        if path.exists(appPath) == False:
            app_errorlogger.error( &#39; - The folder &#34;/application-instance&#34; does not exist!&#39;)
        process = subprocess.Popen([&#39;touch&#39; , appPath + &#39;/&#39; + instanceName + &#39;/STATUS&#39;], stdout=subprocess.PIPE, stderr=subprocess.STDOUT)
        output, error = process.communicate()
        if output:
            app_errorlogger.error( str(output))
        try:
            text_file = open(appPath + &#39;/&#39; + instanceName + &#39;/STATUS&#39;, &#34;w&#34;)
            text_file.write(status)
            text_file.close()
        except Exception:
            app_errorlogger.exception(&#39;Fatal error in writing to STATUS file: &#39;, exc_info=True)
            raise Exception(&#39;Fatal error in writing to STATUS file: &#39;)
        if path.exists(appPath + &#39;/&#39; + instanceName + &#39;/STATUS&#39;) == False:
            app_errorlogger.exception(&#39;Something went wrong during writing to STATUS file: &#39;, exc_info=True)
            raise Exception(&#39;Fatal error in writing to STATUS file: &#39;)


    def lock(self, jobID, instanceName):
        &#39;&#39;&#39;
        Description:
        -----------
        Creates a file named LOCK to lock an app, so that no one is able to perform other operations
        on an app before the current operation is finished.

        Parameters:
        ----------
        Job ID : str
            Unique JobID that consists of an uuid and the datetime

        instanceName : str
            The instance name of the application that is used 
        
        Raises:
        -------
        Exception(&#39;The app you want to use is currently locked! Please try again later!&#39;) if the wanted app is currently locked.

        Returns:
        -------
        
        &#39;&#39;&#39;

        app_logger, bibbox_logger, docker_logger, app_errorlogger = AppController.setUpLog(self, jobID, instanceName)
        app_logger.info( &#39;Ckeck if app is locked&#39; )
        rootdir = dirname(dirname(abspath(__file__)))
        appPath = rootdir + &#39;/application-instance&#39;
        if path.exists(appPath) == False:
            app_errorlogger.error(&#39; - The folder &#34;/application-instance&#34; does not exist!&#39;)
        if &#39;LOCK&#39; in os.listdir(appPath + &#39;/&#39; + instanceName):
            try:
                with open(appPath + &#39;/&#39; + instanceName + &#39;/LOCK&#39;) as lockfile:
                    lockID = lockfile.read()
                    if lockID != jobID:
                        app_errorlogger.exception( &#39; - The app you want to use is currently locked! Please try again later!&#39;)
                        raise Exception(&#39;The app you want to use is currently locked! Please try again later!&#39;)
            except Exception:
                app_errorlogger.exception(&#39;Fatal error in writing to LOCK file: &#39;, exc_info=True)
                raise Exception(&#39;Could not open LOCK file in application folder!&#39;)

        app_logger.debug( &#39;Locking app: &#39; + instanceName )
        process = subprocess.Popen([&#39;touch&#39; , appPath + &#39;/&#39; + instanceName + &#39;/LOCK&#39;], stdout=subprocess.PIPE, stderr=subprocess.STDOUT)
        output, error = process.communicate()
        if output:
            app_errorlogger.error(str(output) )
        if path.exists(appPath + &#39;/&#39; + instanceName + &#39;/LOCK&#39;) == False:
            app_errorlogger.exception(&#39;Something went wrong during writing LOCK file: &#39;, exc_info=True)
            raise Exception(&#39;Fatal error in writing LOCK file: &#39;)

    def unlock(self, jobID, instanceName, end = False):
        &#39;&#39;&#39;
        Description:
        -----------
        Deletes a file named LOCK to lock an app, so that one is able to perform other operations
        on an app after the current operation is finished.

        Parameters:
        ----------
        Job ID : str
            Unique JobID that consists of an uuid and the datetime

        instanceName : str
            The instance name of the application that is used 
        
        Raises:
        -------

        Returns:
        -------
        
        &#39;&#39;&#39;
        rootdir = dirname(dirname(abspath(__file__)))
        appPath = rootdir + &#39;/application-instance&#39;
        if path.exists(appPath) == False:
            app_errorlogger.error(&#39; - The folder &#34;/application-instance&#34; does not exist!&#39;)
        process = subprocess.Popen([&#39;rm&#39; , appPath + &#39;/&#39; + instanceName + &#39;/LOCK&#39;], stdout=subprocess.PIPE, stderr=subprocess.STDOUT)
        output, error = process.communicate()
        if end == False:
            if output:
                app_errorlogger.error(str(output) )
        if path.exists(appPath + &#39;/&#39; + instanceName + &#39;/LOCK&#39;) == True:
            app_errorlogger.exception(&#39;Something went wrong during deleting LOCK file: &#39;, exc_info=True)
            raise Exception(&#39;Fatal error in deleting LOCK file: &#39;)
        app_logger, bibbox_logger, docker_logger, app_errorlogger = AppController.setUpLog(self, jobID, instanceName)
        app_logger.debug(&#39;App &#39; + instanceName + &#39; unlocked&#39;)


    def downloadApp(self, jobID, instanceName,appName,version = &#39;master&#39;):
        &#39;&#39;&#39;
        Description:
        -----------
        Downloads the wanted app from Github before installation.

        Parameters:
        ----------
        Job ID : str
            Unique JobID that consists of an uuid and the datetime

        instanceName : str
            The instance name of the application that is used 

        appName : str
            The (github) name of the application that is used 

        version : str
            The wanted version of the application that is used 
        
        Raises:
        -------

        Returns:
        -------
        
        &#39;&#39;&#39;
        if version == &#39;&#39; or version == None:
            version = &#39;master&#39;
        bibbox_logger = AppController.setUpLog(self, jobID, &#39;system&#39;, systemonly=True)
        try:
            url = &#39;https://raw.githubusercontent.com/bibbox/application-store/master/bibboxV4.json&#39;
            download = requests.get(url).content
        except Exception:
            raise Exception(&#39;Something went wrong during connecting to the GitHub repository. Please Check your internet connection!&#39;)
        try:
            params = simplejson.loads(download)
        except Exception:
            bibbox_logger.exception(&#39;Error while loading bibboxV4.json file: &#39;, exc_info=True)
            raise Exception(&#39;Error while loading bibboxV4.json file&#39;)
        appslist=[]
        
        appNameNew = &#39;app-&#39;+ appName     
        rootdir = dirname(dirname(abspath(__file__)))
        print(rootdir)
        #rootdir = &#39;opt/bibbox/sys-bibbox&#39;
        appPath = rootdir + &#39;/application-instance&#39;
        if path.exists(appPath) == False:
            raise Exception(&#39;The folder &#34;/application-instance&#34; does not exist!&#39;)
        app_logger, bibbox_logger, docker_logger, app_errorlogger = AppController.setUpLog(self, jobID, instanceName)
        app_logger.info( &#39;Downloading app: &#39; + appNameNew + &#39;/&#39; + instanceName + &#39; V:&#39; + version)
        
        process = subprocess.Popen([&#39;git&#39;, &#39;clone&#39;,&#39;-b&#39;, version, &#39;https://github.com/bibbox/&#39; + appNameNew + &#39;.git&#39;, rootdir + &#39;/application-instance/&#39; + instanceName + &#39;/repo/&#39;],text=True, stdout=subprocess.PIPE, stderr=subprocess.STDOUT)
        output, error = process.communicate()
        if output:
            app_logger.debug(str(output).rstrip() )
        if path.exists(appPath + &#39;/&#39; + instanceName + &#39;/repo&#39;) == False:
            app_errorlogger.exception(&#39;Something went wrong during downloading app: &#39; + instanceName, exc_info=True)
            raise Exception(&#39;Fatal error in during downloading app: &#39; + instanceName)
    

    def getAppName(self, appName):
        &#39;&#39;&#39;
        Description:
        -----------
        Returns the repository name for the corresponding application.

        Parameters:
        ----------
        Job ID : str
            Unique JobID that consists of an uuid and the datetime

        instanceName : str
            The instance name of the application that is used 

        appName : str
            The (github) name of the application that is used 

        version : str
            The wanted version of the application that is used 
        
        Raises:
        -------

        Returns:
        -------
        
        &#39;&#39;&#39;
    
        try:
            url = &#39;https://raw.githubusercontent.com/bibbox/application-store/master/bibboxV4.json&#39;
            download = requests.get(url).content
        except Exception:
            raise Exception(&#39;Something went wrong during connecting to the GitHub repository. Please Check your internet connection!&#39;)
        try:
            params = simplejson.loads(download)
        except Exception:
            bibbox_logger.exception(&#39;Error while loading bibboxV4.json file: &#39;, exc_info=True)
            raise Exception(&#39;Error while loading bibboxV4.json file&#39;)
        appslist=[]
        
        appName = &#39;app-&#39;+appName
        sys.stdout.write(appName+ &#39;\n&#39;)
        
        return appName


    def setInfo(self, jobID, instanceName,appName,version):
        &#39;&#39;&#39;
        Description:
        -----------
        Creates a file named INFO where install information is stored.

        Parameters:
        ----------
        Job ID : str
            Unique JobID that consists of an uuid and the datetime

        instanceName : str
            The instance name of the application that is used 

        appName : str
            The (github) name of the application that is used 

        version : str
            The wanted version of the application that is used 
        
        Raises:
        -------

        Returns:
        -------
        
        &#39;&#39;&#39;

        app_logger, bibbox_logger, docker_logger, app_errorlogger = AppController.setUpLog(self, jobID, instanceName)
        app_logger.info( &#39;Set install info&#39;)
        rootdir = dirname(dirname(abspath(__file__)))
        appPath = rootdir + &#39;/application-instance&#39;
        if path.exists(appPath) == False:
            raise Exception(&#39;The folder &#34;/application-instance&#34; does not exist!&#39;)
    
        data = {}
        data[&#39;instanceName&#39;] = instanceName
        data[&#39;appName&#39;] = appName
        data[&#39;version&#39;] = version
        data[&#39;jobID&#39;] = jobID
        try:
            with open(appPath + &#39;/&#39; + instanceName + &#39;/info.json&#39;, &#39;w+&#39;) as outfile:
                json.dump(data, outfile)
        except Exception:
                app_errorlogger.exception(&#39;Could not open file &#34;info.json&#34; in application folder! &#39;, exc_info=True)
                raise Exception(&#39;Could not open file &#34;info.json&#34; in application folder! &#39;)
        if path.exists(appPath + &#39;/&#39; + instanceName + &#39;/info.json&#39;) == False:
            app_errorlogger.exception(&#39;Something went wrong during writing install information to info.json file of app: &#39; + instanceName, exc_info=True)
            raise Exception(&#39;Fatal error in during writing install information to info.json file of app: &#39; + instanceName)


    def changeInfo(self, jobID, instanceName, newName):
        &#39;&#39;&#39;
        Description:
        -----------
        Creates a file named INFO where install information is stored.

        Parameters:
        ----------
        Job ID : str
            Unique JobID that consists of an uuid and the datetime

        instanceName : str
            The instance name of the application that is used 

        appName : str
            The (github) name of the application that is used 

        version : str
            The wanted version of the application that is used 
        
        Raises:
        -------

        Returns:
        -------
        
        &#39;&#39;&#39;

        app_logger, bibbox_logger, docker_logger, app_errorlogger = AppController.setUpLog(self, jobID, instanceName)
        app_logger.info( &#39;Set install info&#39;)
        rootdir = dirname(dirname(abspath(__file__)))
        appPath = rootdir + &#39;/application-instance&#39;
        if path.exists(appPath) == False:
            raise Exception(&#39;The folder &#34;/application-instance&#34; does not exist!&#39;)
        try:
            with open(appPath + &#39;/&#39; + instanceName + &#39;/info.json&#39;) as outfile:
                data = json.load(outfile)
                data[&#39;instanceName&#39;] = newName
                data[&#39;jobID&#39;] = jobID
        except Exception:
                app_errorlogger.exception(&#39;Could not open file &#34;info.json&#34; in application folder! &#39;, exc_info=True)
                raise Exception(&#39;Could not open file &#34;info.json&#34; in application folder! &#39;)
        try:
            with open(appPath + &#39;/&#39; + newName + &#39;/info.json&#39;, &#39;w+&#39;) as outfile:
                json.dump(data, outfile)
        except Exception:
                app_errorlogger.exception(&#39;Could not open file &#34;info.json&#34; in application folder! &#39;, exc_info=True)
                raise Exception(&#39;Could not write to file &#34;info.json&#34; in application folder! &#39;)


    def setProxyFiles(self, jobID, instanceName, containerName):
        &#39;&#39;&#39;
        Description:
        -----------
        Creates a proxy config file for the nginx web server to use the app container as sub url.

        Parameters:
        ----------
        Job ID : str
            Unique JobID that consists of an uuid and the datetime

        instanceName : str
            The instance name of the application that is used 

        containerName : str
            The name of the container, that is runninng the application 

        
        Raises:
        -------

        Returns:
        -------
        
        &#39;&#39;&#39;

        app_logger, bibbox_logger, docker_logger, app_errorlogger = AppController.setUpLog(self, jobID, instanceName)
        app_logger.info( &#39;Set proxy files&#39;)
        rootdir = dirname(dirname(abspath(__file__)))
        proxyPath = rootdir + &#39;/sys-proxy/&#39;
        if path.exists(proxyPath) == False:
            app_errorlogger.error(&#39;The folder &#34;sys-proxy&#34; does not exist!&#39;)
        if path.exists(proxyPath + &#39;proxyconfig/sites/&#39;) == False:
            process = subprocess.Popen([&#39;mkdir&#39;, proxyPath + &#39;proxyconfig/sites/&#39;])
            output, error = process.communicate()
            if output:
                bibbox_logger.debug( str(output))
        name = instanceName + &#39;.conf&#39;
        
        try:
            with open(proxyPath + &#39;template.conf&#39;) as template:
                file_content = template.read()
                file_content = file_content.replace(&#34;§§INSTANCEID&#34;, instanceName)
                file_content = file_content.replace(&#34;§§CONTAINERNAME&#34;, containerName)
                template = open( proxyPath + &#39;proxyconfig/sites/&#39; + name, &#39;w+&#39;)
                template.write(file_content)
                template.close()
        except Exception:
            app_errorlogger.exception(&#39;Fatal error in writing to proxy template file: &#39;, exc_info=True)
        if path.exists(proxyPath + &#39;proxyconfig/sites/&#39; + name) == False:
            app_errorlogger.exception(&#39;Something went wrong during writing the proxy file for app: &#39; + instanceName, exc_info=True)
            raise Exception(&#39;Fatal error in during writing the proxy file for app: &#39; + instanceName)
        
    def readContainernames(self, jobID, instanceName):
        &#39;&#39;&#39;
        Description:
        -----------
        Reads the container name from the docker-compose-template.yml file.

        Parameters:
        ----------
        Job ID : str
            Unique JobID that consists of an uuid and the datetime

        instanceName : str
            The instance name of the application that is used 
        
        Raises:
        -------

        Returns:
        -------
        ContainerNames: list
            The names of the containers, that are runninng the application
        mainContainer: str
            The name of the main container
        &#39;&#39;&#39;

        app_logger, bibbox_logger, docker_logger, app_errorlogger = AppController.setUpLog(self, jobID, instanceName)
        app_logger.info( &#39;Read Containernames&#39;)
        rootdir = dirname(dirname(abspath(__file__)))
        appPath = rootdir + &#39;/application-instance&#39;
        if path.exists(appPath) == False:
            raise Exception(&#39;The folder &#34;/application-instance&#34; does not exist!&#39;)
        composefile = open(appPath + &#39;/&#39; + instanceName +&#39;/repo/docker-compose-template.yml&#39;, &#39;r&#39;).read()
        try:
            data = yaml.load(composefile, Loader=yaml.FullLoader)
        except Exception:
            app_errorlogger.exception(&#39;Fatal error in loading compose file: &#39;, exc_info=True)
        ContainerNames = []
        try:
            for k, v in data[&#34;services&#34;].items():
                if &#39;container_name&#39; in v:
                    mainContainer = v.get(&#39;container_name&#39;)
                    mainContainer = mainContainer.replace(&#39;§§INSTANCE&#39;, instanceName)
                    try:
                        mainContainer = mainContainer.replace(&#39;-db&#39;, &#39;&#39;)
                    except:
                        pass
                if &#39;container_name&#39; in v:
                    ContainerName = v.get(&#39;container_name&#39;)
                    ContainerName = ContainerName.replace(&#39;§§INSTANCE&#39;, instanceName)
                    ContainerNames.append(ContainerName)
        except Exception:
            app_errorlogger.exception(&#39;Fatal error in reading compose file: &#39;, exc_info=True)

        return ContainerNames, mainContainer

    def writeCompose(self, jobID, paramList, instanceName):
        &#39;&#39;&#39;
        Description:
        -----------
        Changes the instance name of the docker-compose-template.yml file.

        Parameters:
        ----------
        Job ID : str
            Unique JobID that consists of an uuid and the datetime

        paramList: array
            list of environment variables that are defined in the .env file in the repository of the application

        instanceName : str
            The instance name of the application that is used 
        
        Raises:
        -------

        Returns:
        -------
        &#39;&#39;&#39;

        app_logger, bibbox_logger, docker_logger, app_errorlogger = AppController.setUpLog(self, jobID, instanceName)
        app_logger.info(&#39;Write parameters to compose file&#39;)
        rootdir = dirname(dirname(abspath(__file__)))
        appPath = rootdir + &#39;/application-instance/&#39; + instanceName + &#39;/repo/&#39;
        if path.exists(appPath) == False:
            raise Exception(&#39;The folder &#34;/application-instance&#34; does not exist!&#39;)
        try:
            compose = open(appPath + &#39;/docker-compose-template.yml&#39;, &#39;r&#39;).read()
        except Exception:
            app_errorlogger.exception(&#39;Fatal error in reading compose file: &#39;, exc_info=True)

        try:
            for i, key in enumerate(paramList):
                compose = compose.replace(&#39;§§&#39; + key, paramList[key])
        except Exception:
            app_errorlogger.exception(&#39;Fatal error in writing to compose file: &#39;, exc_info=True)
        try:
            compose = compose.replace(&#39;§§INSTANCE&#39;, instanceName)
            target = open(appPath + &#39;/docker-compose-template.yml&#39;, &#39;w&#39;)
            target.write(compose)
            target.close()
        except Exception:
            app_errorlogger.exception(&#39;Fatal error in writing to compose file: &#39;, exc_info=True)



    def writeCLICompose(self, jobID, paramList, keyList, instanceName):
        &#39;&#39;&#39;
        Description:
        -----------
        Changes the instance name of the docker-compose-template.yml file.

        Parameters:
        ----------
        Job ID : str
            Unique JobID that consists of an uuid and the datetime

        paramList: array
            list of environment variables that are defined in the .env file in the repository of the application

        instanceName : str
            The instance name of the application that is used 
        
        Raises:
        -------

        Returns:
        -------
        &#39;&#39;&#39;

        app_logger, bibbox_logger, docker_logger, app_errorlogger = AppController.setUpLog(self, jobID, instanceName)
        app_logger.info(&#39;Write parameters to compose file&#39;)
        rootdir = dirname(dirname(abspath(__file__)))
        appPath = rootdir + &#39;/application-instance/&#39; + instanceName + &#39;/repo/&#39;
        if path.exists(appPath) == False:
            raise Exception(&#39;The folder &#34;/application-instance&#34; does not exist!&#39;)
        try:
            compose = open(appPath + &#39;/docker-compose-template.yml&#39;, &#39;r&#39;).read()
        except Exception:
            app_errorlogger.exception(&#39;Fatal error in reading compose file: &#39;, exc_info=True)
        paramList = re.sub(&#34;[^\w]&#34;, &#34; &#34;, paramList).split()
        
        keyList = re.sub(&#34;[^\w]&#34;, &#34; &#34;, keyList).split()
        
        
        for i, key in enumerate(keyList):
            if key != &#39;&#39;:
                compose = compose.replace(&#39;§§&#39; + key, paramList[i])
        
        
        compose = compose.replace(&#39;§§INSTANCE&#39;, instanceName)
        target = open(appPath + &#39;/docker-compose-template.yml&#39;, &#39;w&#39;)
        target.write(compose)
        target.close()
        


    def composeUp(self, jobID, instanceName, containerName):
        &#39;&#39;&#39;
        Description:
        -----------
        Executes the doker-compose up command and starts the application

        Parameters:
        ----------
        Job ID : str
            Unique JobID that consists of an uuid and the datetime

        instanceName : str
            The instance name of the application that is used 
        
        Raises:
        -------

        Returns:
        -------
        &#39;&#39;&#39;

        app_logger, bibbox_logger, docker_logger, app_errorlogger = AppController.setUpLog(self, jobID, instanceName)
        app_logger.info( &#39;Docker compose up&#39;)
        rootdir = dirname(dirname(abspath(__file__)))
        appPath = rootdir + &#39;/application-instance/&#39; + instanceName + &#39;/repo/&#39;
        if path.exists(appPath) == False:
            raise Exception(&#39;The folder &#34;/application-instance&#34; does not exist!&#39;)
        process = subprocess.Popen([&#39;docker-compose&#39;, &#39;-f&#39;, appPath + &#39;/docker-compose-template.yml&#39;, &#39;up&#39;, &#39;-d&#39;], stdout=subprocess.PIPE, stderr=subprocess.STDOUT, encoding=&#34;utf8&#34;)
        output, error = process.communicate()
        if output:
            docker_logger.error( str(output).rstrip())
        process = subprocess.Popen([&#39;docker&#39;, &#39;exec&#39;, &#39;-it&#39;, &#39;local_nginx&#39;, &#39;service&#39;, &#39;nginx&#39;, &#39;reload&#39;], stdout=subprocess.PIPE, stderr=subprocess.STDOUT, encoding=sys.stdout.encoding)
        output, error = process.communicate()
        ansi_regex = r&#39;\x1b+\[+\d+\d+;+\d+\d+[m]|&#39; \
             r&#39;\x1b(&#39; \
             r&#39;(\[\??\d+[hl])|&#39; \
             r&#39;([=&lt;&gt;a-kzmNM78])|&#39; \
             r&#39;([\(\)][a-b0-2])|&#39; \
             r&#39;(\[\d{0,2}[ma-dgkjqi])|&#39; \
             r&#39;(\[\d+;\d+[hfy]?)|&#39; \
             r&#39;(\[;?[hf])|&#39; \
             r&#39;(#[3-68])|&#39; \
             r&#39;([01356]n)|&#39; \
             r&#39;(O[mlnp-z]?)|&#39; \
             r&#39;(/Z)|&#39; \
             r&#39;(\d+)|&#39; \
             r&#39;(\[\?\d;\d0c)|&#39; \
             r&#39;(\d;\dR)|&#39; \
             r&#39;(\[*\d*\d*;*\d*\d*[m]))&#39; 
             
        ansi_escape = re.compile(ansi_regex, flags=re.IGNORECASE)
        result = ansi_escape.sub(&#39;&#39;, output).rstrip()
        if output:
            bibbox_logger.debug( str(output).rstrip())
        process = subprocess.Popen([&#39;docker&#39;, &#39;logs&#39;, containerName], stdout=subprocess.PIPE, stderr=subprocess.STDOUT, encoding=&#34;utf8&#34;)
        output, error = process.communicate()
        if output:
            docker_logger.debug( str(output).rstrip())
        try:
            process = subprocess.Popen([&#39;docker&#39;, &#39;exec&#39;, containerName, &#39;/var/entrypoint.sh&#39;], stdout=subprocess.PIPE, stderr=subprocess.STDOUT, encoding=&#34;utf8&#34;)
            output, error = process.communicate()
            if output:
                docker_logger.debug( str(output).rstrip())
        except:
            pass

    def stop(self, jobID, instanceName):
        &#39;&#39;&#39;
        Description:
        -----------
        Executes the doker-compose stop command to stop the application

        Parameters:
        ----------
        Job ID : str
            Unique JobID that consists of an uuid and the datetime

        instanceName : str
            The instance name of the application that is used 
        
        Raises:
        -------

        Returns:
        -------
        &#39;&#39;&#39;

        app_logger, bibbox_logger, docker_logger, app_errorlogger = AppController.setUpLog(self, jobID, instanceName)
        app_logger.info( &#39;Stopping App:&#39; + instanceName)
        rootdir = dirname(dirname(abspath(__file__)))
        appPath = rootdir + &#39;/application-instance/&#39; + instanceName + &#39;/repo/&#39;
        if path.exists(appPath) == False:
            app_logger.error(&#39;The folder of the app repository does not exist!&#39;)
        process = subprocess.Popen([&#39;docker-compose&#39;, &#39;-f&#39;, appPath + &#39;/docker-compose-template.yml&#39;, &#39;stop&#39;], stdout=subprocess.PIPE, stderr=subprocess.STDOUT, encoding=&#34;utf8&#34;)
        output, error = process.communicate()
        if output:
            docker_logger.error( str(output).rstrip())

    def start(self, jobID, instanceName):
        &#39;&#39;&#39;
        Description:
        -----------
        Executes the doker-compose start command to start the application

        Parameters:
        ----------
        Job ID : str
            Unique JobID that consists of an uuid and the datetime

        instanceName : str
            The instance name of the application that is used 
        
        Raises:
        -------

        Returns:
        -------
        &#39;&#39;&#39;

        app_logger, bibbox_logger, docker_logger, app_errorlogger = AppController.setUpLog(self, jobID, instanceName)
        app_logger.info( &#39;Starting App:&#39; + instanceName)
        rootdir = dirname(dirname(abspath(__file__)))
        appPath = rootdir + &#39;/application-instance/&#39; + instanceName + &#39;/repo/&#39;
        if path.exists(appPath) == False:
            app_errorlogger.error( &#39; The folder of the app repository does not exist!&#39;)
        process = subprocess.Popen([&#39;docker-compose&#39;, &#39;-f&#39;, appPath + &#39;/docker-compose-template.yml&#39;, &#39;start&#39;], stdout=subprocess.PIPE, stderr=subprocess.STDOUT, encoding=&#34;utf8&#34;)
        output, error = process.communicate()
        if output:
            docker_logger.error( str(output).rstrip())

    def remove(self, jobID, instanceName):
        &#39;&#39;&#39;
        Description:
        -----------
        Executes the doker-compose down command to stop and remove the application

        Parameters:
        ----------
        Job ID : str
            Unique JobID that consists of an uuid and the datetime

        instanceName : str
            The instance name of the application that is used 
        
        Raises:
        -------

        Returns:
        -------
        &#39;&#39;&#39;

        app_logger, bibbox_logger, docker_logger, app_errorlogger = AppController.setUpLog(self, jobID, instanceName)
        app_logger.info( &#39;Removing App:&#39; + instanceName)
        rootdir = dirname(dirname(abspath(__file__)))
        appPath = rootdir + &#39;/application-instance/&#39; + instanceName + &#39;/repo/&#39;
        if path.exists(appPath) == False:
            app_errorlogger.error( &#39;The folder of the app repository does not exist!&#39;)
        process = subprocess.Popen([&#39;docker-compose&#39;, &#39;-f&#39;, appPath + &#39;/docker-compose-template.yml&#39;, &#39;down&#39;], stdout=subprocess.PIPE, stderr=subprocess.STDOUT, encoding=&#34;utf8&#34;)
        output, error = process.communicate()
        if output:
            docker_logger.error( str(output))
        process = subprocess.Popen([&#39;sudo&#39;, &#39;chmod&#39; ,&#39;-f&#39;, &#39;-R&#39;, &#39;777&#39;, rootdir + &#39;/application-instance/&#39; + instanceName], stdout=subprocess.PIPE, stderr=subprocess.STDOUT, encoding=&#34;utf8&#34;)
        output, error = process.communicate()
        if output:
            bibbox_logger.error( str(output))
        process = subprocess.Popen([&#39;rm&#39; , &#39;-f&#39;, &#39;-R&#39;, rootdir + &#39;/application-instance/&#39; + instanceName], stdout=subprocess.PIPE, stderr=subprocess.STDOUT, encoding=&#34;utf8&#34;)
        output, error = process.communicate()
        if output:
            bibbox_logger.error( str(output))
        process = subprocess.Popen([&#39;rm&#39; , &#39;-f&#39;, rootdir + &#39;/sys-proxy/proxyconfig/sites/&#39; + instanceName + &#39;.conf&#39;], stdout=subprocess.PIPE, stderr=subprocess.STDOUT, encoding=&#34;utf8&#34;)
        output, error = process.communicate()
        if output:
            bibbox_logger.error( str(output))

    def status(self, jobID, instanceName):
        &#39;&#39;&#39;
        Description:
        -----------
        Reads the file STATUS to get the currend state of an application

        Parameters:
        ----------
        Job ID : str
            Unique JobID that consists of an uuid and the datetime

        instanceName : str
            The instance name of the application that is used 
        
        Raises:
        -------

        Returns:
        -------
        status: str
            The current status of an application
        &#39;&#39;&#39;

        app_logger, bibbox_logger, docker_logger, app_errorlogger = AppController.setUpLog(self, jobID, instanceName)
        app_logger.info( &#39;Reading Status of App: &#39; + instanceName)
        rootdir = dirname(dirname(abspath(__file__)))
        appPath = rootdir + &#39;/application-instance/&#39; + instanceName + &#39;/&#39;
        if path.exists(appPath) == False:
            app_errorlogger.error( &#39; The folder of the app repository does not exist!&#39;)
        try:
            with open(appPath + &#39;STATUS&#39;) as statusfile:
                file_content = statusfile.read()
        except Exception:
            app_errorlogger.exception(&#39;Could not open STATUS file: &#39;, exc_info=True)
        return file_content

    def checkStatus(self, jobID, instanceName, statusList):
        &#39;&#39;&#39;
        Description:
        -----------
        Reads the file STATUS to get the currend state of an application and checks, if the status is allowed for the wanted operation.

        Parameters:
        ----------
        Job ID : str
            Unique JobID that consists of an uuid and the datetime

        instanceName : str
            The instance name of the application that is used 

        statusList: array
            List of states, that allow a specific operation on an application
        
        Raises:
        -------
        raise Exception(&#39;Current app status does not allow your operation!&#39;) if the currend status is not in the statuslist

        Returns:
        -------
        
        &#39;&#39;&#39;

        app_logger, bibbox_logger, docker_logger, app_errorlogger = AppController.setUpLog(self, jobID, instanceName)
        app_logger.info( &#39;Checking if operation is possible for current state of app: &#39; + instanceName)
        rootdir = dirname(dirname(abspath(__file__)))
        appPath = rootdir + &#39;/application-instance/&#39; + instanceName + &#39;/&#39;
        if path.exists(appPath) == False:
            app_errorlogger.debug(&#39;The folder of the app repository does not exist!&#39;)
        try:
            with open(appPath + &#39;STATUS&#39;) as statusfile:
                file_content = statusfile.read()
                
        except Exception:
            logging.exception(&#39;Could not open STATUS file: &#39;, exc_info=True)
        if file_content not in statusList:
            app_errorlogger.exception(&#39;Current app status does not allow operation on app: &#39; + instanceName)
            raise Exception(&#39;Current app status does not allow your operation!&#39;)

    def copy(self, jobID, instanceName, newName):
        &#39;&#39;&#39;
        Description:
        -----------
        Copies the current app folder to the new app destination.

        Parameters:
        ----------
        Job ID : str
            Unique JobID that consists of an uuid and the datetime

        instanceName: str
            The instance name of the application that is used 

        newName: str
            New name of the copied application
        
        Raises:
        -------

        Returns:
        -------
        
        &#39;&#39;&#39;

        app_logger, bibbox_logger, docker_logger,  app_errorlogger = AppController.setUpLog(self, jobID, instanceName)
        app_logger.info(&#39;Copy App:&#39; + instanceName)
        rootdir = dirname(dirname(abspath(__file__)))
        appPath = rootdir + &#39;/application-instance/&#39; + instanceName + &#39;/repo/&#39;
        if path.exists(appPath) == False:
            app_errorlogger.error(&#39;The folder of the app repository does not exist!&#39;)
        process = subprocess.Popen([&#39;sudo&#39;, &#39;chmod&#39;, &#39;-R&#39;, &#39;777&#39;, rootdir + &#39;/application-instance/&#39; +  instanceName], stdout=subprocess.PIPE, stderr=subprocess.STDOUT)
        output, error = process.communicate()
        if output:
            app_errorlogger.error( str(output))
        process = subprocess.Popen([&#39;cp&#39;, &#39;-r&#39;, rootdir + &#39;/application-instance/&#39; + instanceName, rootdir + &#39;/application-instance/&#39; + newName], stdout=subprocess.PIPE, stderr=subprocess.STDOUT)
        output, error = process.communicate()
        if output:
            app_errorlogger.error( str(output))
        

    def changeCompose(self, jobID, instanceName, newName):
        &#39;&#39;&#39;
        Description:
        -----------
        Reads the file STATUS to get the currend state of an application and checks, if the status is allowed for the wanted operation.

        Parameters:
        ----------
        Job ID : str
            Unique JobID that consists of an uuid and the datetime

        paramList: array
            list of environment variables that are defined in the .env file in the repository of the application

        instanceName : str
            The instance name of the application that is used 

        newName: str
            new instance name name of copied application
        
        Raises:
        -------

        Returns:
        -------
        
        &#39;&#39;&#39;

        app_logger, bibbox_logger, docker_logger, app_errorlogger = AppController.setUpLog(self, jobID, instanceName)
        app_logger.info( &#39;Write parameters to compose file&#39;)
        rootdir = dirname(dirname(abspath(__file__)))
        appPath = rootdir + &#39;/application-instance/&#39; + instanceName + &#39;/repo/&#39;
        if path.exists(appPath) == False:
            app_errorlogger.error(&#39; The folder of the app repository does not exist!&#39;)
        newAppPath = rootdir + &#39;/application-instance/&#39; + newName + &#39;/repo/&#39;
        try:
            compose = open(appPath + &#39;/docker-compose-template.yml&#39;, &#39;r&#39;)
        except Exception:
            app_errorlogger.exception(&#39;Fatal error in reading compose file: &#39;, exc_info=True)
        try:
            compose = yaml.load(compose)
            services = compose[&#39;services&#39;]
        except Exception:
            app_errorlogger.exception(&#39;Fatal error in reading compose file: &#39;, exc_info=True)
        try:
            for service in services:
                name = services[service][&#39;container_name&#39;]
                newContainerName = name.replace(instanceName, newName)
                services[service][&#39;container_name&#39;] = newContainerName
                try:
                    name = services[service][&#39;links&#39;]
                    newContainerName = name[0].replace(instanceName, newName)
                    services[service][&#39;links&#39;] = [newContainerName]
                except:
                    pass
                try:
                    name = services[service][&#39;depends_on&#39;]
                    newContainerName = name[0].replace(instanceName, newName)
                    services[service][&#39;depends_on&#39;] = [newContainerName]
                except:
                    pass
        except Exception:
            app_errorlogger.exception(&#39;Fatal error in reading compose file: &#39;, exc_info=True)
        try:    
            composenew = copy.deepcopy(compose)
        except Exception:
            app_errorlogger.exception(&#39;Fatal error while copying compose file: &#39;, exc_info=True)
        try:
            for service in services:
                newServiceName = service.replace(instanceName, newName)           
                composenew[&#39;services&#39;][newServiceName] = composenew[&#39;services&#39;][service]
                del composenew[&#39;services&#39;][service]
        except Exception:
            app_errorlogger.exception(&#39;Fatal error while writing to compose file: &#39;, exc_info=True)
        try:
            composefile = yaml.dump(composenew)
            os.system(&#39;sudo chmod -R 777 &#39; + newAppPath)
            target = open(newAppPath + &#39;docker-compose-template.yml&#39;, &#39;w&#39;)
            target.write(composefile)
            target.close()
        except Exception:
            app_errorlogger.exception(&#39;Fatal error while writing to compose file: &#39;, exc_info=True)

    def readVersion(self, jobID, appName):
        &#39;&#39;&#39;
        Description:
        -----------
        Lists the available Apps.

        Parameters:
        ----------

        Raises:
        -------

        Returns:
        -------
        appslist: json object
            The list of all available apps as json object
        &#39;&#39;&#39;

        try:
            url = &#39;https://raw.githubusercontent.com/bibbox/application-store/master/eB3Kit.json&#39;
            download = requests.get(url).content
        except Exception:
            raise Exception(&#39;Something went wrong during connecting to the GitHub repository. Please Check your internet connection!&#39;)
        try:
            params = simplejson.loads(download)
        except Exception:
            #app_errorlogger.exception(&#39;Error while loading eB3Kit.json file: &#39;, exc_info=True)
            raise Exception(&#39;Error while loading eB3Kit.json file&#39;)
        versionList=[]
        try:
            for i, values in enumerate(params):
                variable = values[&#39;group_members&#39;]
                for i, var in enumerate(variable):
                    if var[&#39;app_name&#39;] == appName:
                        versions = var[&#39;versions&#39;]
                        for version in versions:
                            versionList.append(version[&#39;docker_version&#39;])
                    if var[&#39;app_display_name&#39;] == appName:
                        versions = var[&#39;versions&#39;]
                        for version in versions:
                            versionList.append(version[&#39;docker_version&#39;])
        except:
            raise Exception(&#39;The wanted app does not exist. Please check the list of available apps!&#39;)                

        return versionList

    def readAppStore(self, jobID, instanceName):
        &#39;&#39;&#39;
        Description:
        -----------
        Lists the available Apps.

        Parameters:
        ----------

        Raises:
        -------

        Returns:
        -------
        appslist: json object
            The list of all available apps as json object
        &#39;&#39;&#39;
        bibbox_logger = AppController.setUpLog(self, jobID, &#39;system&#39;, systemonly=True)
        try:
            url = &#39;https://raw.githubusercontent.com/bibbox/application-store/master/eB3Kit.json&#39;
            download = requests.get(url).content
        except Exception:
            raise Exception(&#39;Something went wrong during connecting to the GitHub repository. Please Check your internet connection!&#39;)
        try:
            params = simplejson.loads(download)
        except Exception:
            bibbox_logger.exception(&#39;Error while loading eB3Kit.json file: &#39;, exc_info=True)
            raise Exception(&#39;Error while loading eB3Kit.json file&#39;)
        appslist=[]
        try:
            for i, values in enumerate(params):
                variable = values[&#39;group_members&#39;]
                for i, var in enumerate(variable):
                    appName = var[&#39;app_name&#39;]
                    if appName not in appslist:
                        appslist.append(appName)
        except Exception:
            raise Exception(&#39;Error while loading eB3Kit.json file!&#39;)
            bibbox_logger.exception(&#39;Error while loading eB3Kit.json file: &#39;, exc_info=True)                

        return appslist
        


    def getInstalledApps(self, jobID, instanceName):
        &#39;&#39;&#39;
        Description:
        -----------
        Lists the available Apps.

        Parameters:
        ----------

        Raises:
        -------

        Returns:
        -------
        installedAppslist: json object
            The list of all installed apps as json object
        &#39;&#39;&#39;

        bibbox_logger = AppController.setUpLog(self, jobID, instanceName, systemonly=True)
        rootdir = dirname(dirname(abspath(__file__)))
        appPath = rootdir + &#39;/application-instance/&#39; 
        if path.exists(appPath) == False:
            app_erbibbox_loggerrorlogger.error(&#39; The folder of the app repository does not exist!&#39;)
        installedApps = {}
        try:
            for i, folder in enumerate(os.listdir(appPath)):
                with open(appPath + &#39;/&#39; + folder + &#39;/info.json&#39;) as infofile:
                    data = json.load(infofile)
                    instanceName = data[&#39;instanceName&#39;]
                    appName = data[&#39;appName&#39;]
                    installedApps[instanceName] = appName
        except Exception:
                bibbox_logger.exception(&#39;Could not open file &#34;info.json&#34; in application folder! &#39;, exc_info=True)
                raise Exception(&#39;Could not open file &#34;info.json&#34; in application folder! &#39;)
                
                
        installedAppsList = json.dumps(installedApps)
        return installedAppsList

    def checkDockerState(self, jobID, instanceName, containerNames, allowedStates):
        &#39;&#39;&#39;
        Description:
        -----------
        Ckecks the states of all containers of an app.

        Parameters:
        ----------

        jobID : str
            Unique JobID that consists of an uuid and the datetime

        instanceName : str
            The instance name of the application that is used 

        containerNames: array
            list of used containers
        
        Raises:
        -------

        Returns:
        -------
        
        &#39;&#39;&#39;
        app_logger, bibbox_logger, docker_logger, app_errorlogger = AppController.setUpLog(self, jobID, instanceName)
        app_logger.info(&#39;Checking states of all containers of app: &#39; + instanceName)
        states = {}
        for name in containerNames:
            process = subprocess.Popen([&#39;docker&#39;, &#39;container&#39;, &#39;inspect&#39;, name], stdout=subprocess.PIPE, stderr=subprocess.STDOUT)
            output, error = process.communicate()
            try:
                params = simplejson.loads(output)
                status = params[0][&#39;State&#39;][&#39;Status&#39;]
                states[name] = status
            except Exception:
                app_errorlogger.exception(&#39;Could not load status of wanted container. &#39; + name + &#39; Maybe this container got removed manually. Please look at the log files!&#39;, exc_info=True)
                raise Exception(&#39;Could not load status of wanted container &#39; + name + &#39; Maybe this container got removed manually. Please look at the log files!&#39;)
            if &#39;all&#39; in allowedStates:
                pass
            else:
                if status not in allowedStates:
                    app_errorlogger.error(&#39;Could not perform the wanted task. The allowed states of the app containers are: &#34;&#39; + &#39;, &#39;.join([str(elem) for elem in allowedStates]) + &#39;&#34;. But the container of app &#39; + instanceName + &#39; has state &#39; + status + &#39;.&#39;)
                    raise Exception(&#39;Could not perform the wanted task. The allowed states of the app containers are: &#39; + &#39;, &#34;&#39;.join([str(elem) for elem in allowedStates]) + &#39;&#34;. But the container of app &#39; + instanceName + &#39; has state &#39; + status + &#39;.&#39;)

        return states

    def checkProxy(self, containerName):
        &#39;&#39;&#39;
        Description:
        -----------
        Ckecks the state of the proxy container.

        Parameters:
        ----------

        containerNames: array
            list of used containers
        
        Raises:
        -------

        Returns:
        -------
        
        &#39;&#39;&#39;
        bibbox_logger = AppController.setUpLog(self, &#39;system check&#39;, &#39;system &#39;, systemonly=True)
        bibbox_logger.info(&#39;Performing proxy check!&#39;)
        states = {}
        process = subprocess.Popen([&#39;docker&#39;, &#39;container&#39;, &#39;inspect&#39;, containerName], stdout=subprocess.PIPE, stderr=subprocess.STDOUT)
        output, error = process.communicate()
        state = &#39;&#39;
        try:
            params = simplejson.loads(output)
            state = params[0][&#39;State&#39;][&#39;Status&#39;]
        
            
            if state == &#39;running&#39;:
                 bibbox_logger.info(&#39;The nginx Container is running. \n Everything OK.&#39;)
            else:
                 bibbox_logger.error(&#39;The nginx Container is not running. \n Please try to restart the bibbox System.&#39;)
        except:
             bibbox_logger.error(&#39;The nginx Container is not running. \n Please try to restart the bibbox System with &#34;bibbox restartSystem&#34;.&#39;)

        return state

    def checkSystem(self):
        &#39;&#39;&#39;
        Description:
        -----------
        System Check. Checks the versions of the required packages.

        Parameters:
        ----------

        containerNames: array
            list of used containers
        
        Raises:
        -------

        Returns:
        -------
        
        &#39;&#39;&#39;

        bibbox_logger = AppController.setUpLog(self, &#39;system check&#39;, &#39;system &#39;, systemonly=True)
        bibbox_logger.info(&#39;Performing system check!&#39;)

        if float(str(sys.version_info[0]) + &#39;.&#39; + str(sys.version_info[1])) &gt; 3.5:
            bibbox_logger.info(&#39;Python Version: &#39; + str(sys.version_info[0]) + &#39;.&#39; + str(sys.version_info[1]) + &#39; ---&gt; OK!&#39;)
        else:
            bibbox_logger.error(&#39;You are using a Python version below 3.5 or do not have Python installed. Please install Python 3.5+!&#39;)
            bibbox_logger.error(output)

        process = subprocess.Popen([&#39;docker&#39;, &#39;version&#39;, &#39;--format&#39;, &#39;{{.Server.Version}}&#39;], stdout=subprocess.PIPE, stderr=subprocess.STDOUT)
        output, error = process.communicate()
        output = output.decode(&#39;utf-8&#39;)
        if version.parse(output) &gt; version.parse(&#34;19.03.00&#34;):
            bibbox_logger.info(&#39;Docker Version: &#39; + output + &#39; ---&gt; OK!&#39;)
        else:
            bibbox_logger.error(&#39;You are using a Docker Engine version below 19.03.0 or do not have Docker Engine installed. Please install Docker Engine 19.03.0+!&#39;)
            bibbox_logger.error(output)

        process = subprocess.Popen([&#39;docker-compose&#39;, &#39;version&#39;,  &#39;--short&#39;], stdout=subprocess.PIPE, stderr=subprocess.STDOUT)
        output, error = process.communicate()
        output = output.decode(&#39;utf8&#39;)
        
        if version.parse(str(output)) &gt; version.parse(&#34;1.26.0&#34;):
            bibbox_logger.info(&#39;Docker-Compose Version: &#39; + output + &#39; ---&gt;  OK!&#39;)
        else:
            bibbox_logger.error(&#39;You are using a Docker Compose version below 1.26.0 or do not have Docker Compose installed. Please install Docker Compose 1.26.0+!&#39;)
            bibbox_logger.error(output)

        process = subprocess.Popen([&#39;docker&#39;, &#39;network&#39;, &#39;create&#39;, &#39;bibbox-default-network&#39;], stdout=subprocess.PIPE, stderr=subprocess.STDOUT)
        output, error = process.communicate()
        output = output.decode(&#39;utf8&#39;)
        if output:
            bibbox_logger.debug(&#39;Creating default network:&#39; + output)

        bibbox_logger.info(&#39;Check internet connection&#39;)
        try:
            requests.get(&#39;http://216.58.192.142&#39;, timeout=1)
            bibbox_logger.debug(&#39;Internet connection ---&gt; OK&#39;)
        except: 
            bibbox_logger.error(&#39;Can not connect to the internet!&#39;)

    def checkInput(self, jobID, instanceName, inputparams):
        &#39;&#39;&#39;
        Description:
        -----------
        Ckecks if the userinput is valid.

        Parameters:
        ----------

        jobID : str
            Unique JobID that consists of an uuid and the datetime

        instanceName : str
            The instance name of the application that is used 

        input: array
            List of used parameters to check
        
        Raises:
        -------

        Returns:
        -------
        
        &#39;&#39;&#39;
        bibbox_logger = AppController.setUpLog(self, jobID, instanceName, systemonly = True)
        if type(instanceName) != str:
            bibbox_logger.debug(&#39;The input &#39; + instanceName + &#39; is not valid! Must be a string, but has type &#39; + type(instanceName) + &#39;!&#39;)
        validAll = True
        if not inputparams:
            bibbox_logger.info(&#39;There are no input parameters to check&#39;)
        for var in inputparams:
            valid = bool(re.match(&#39;^[a-zA-Z0-9\-]*$&#39;,var))
            negativeList = [&#39;admin&#39;]
            for param in negativeList:
                if param in var:
                    validAll = False
                    bibbox_logger.debug(&#39;The input &#39; + var + &#39; is not valid!&#39;)
            if valid == False:
                validAll = False
                bibbox_logger.debug(&#39;The input &#39; + var + &#39; is not valid!&#39;)

        if validAll == True:
            bibbox_logger.debug(&#39;The tested input is valid!&#39;)
        if validAll == False:
            bibbox_logger.debug(&#39;The tested input is not valid!&#39;)

        return validAll

    def checkInstall(self, jobID, instanceName, states):
        &#39;&#39;&#39;
        Description:
        -----------
        After the installation of an app, this function checks if the installation was sucessfull and the app is running.

        Parameters:
        ----------

        jobID : str
            Unique JobID that consists of an uuid and the datetime

        instanceName : str
            The instance name of the application that is used 

        states: json Object
            List of installed containers and their corresponding state
        
        Raises:
        -------

        Returns:
        -------
        
        &#39;&#39;&#39;
        app_logger, bibbox_logger, docker_logger, app_errorlogger = AppController.setUpLog(self, jobID, instanceName)
        app_logger.info(&#39;Checking if installation of app &#39; + instanceName + &#39; was successful!&#39;)
        for container in states:
            state = states[container]
            if state != &#39;running&#39;:
                try: 
                    AppController.startApp(self, instanceName)
                except:
                    pass
            if state != &#39;running&#39;:
                AppController.removeApp(self, instancename)
                app_logger.error(&#39;The installation could not be completed. Please read the logs and try again&#39;)

    def startNginx(self, JobID):
        &#39;&#39;&#39;
        Description:
        -----------
        Starts the nginx proxy of the bibbox system.

        Parameters:
        ----------

        jobID : str
            Unique JobID that consists of an uuid and the datetime

        
        Raises:
        -------

        Returns:
        -------
        
        &#39;&#39;&#39;
        bibbox_logger = AppController.setUpLog(self, JobID, &#39;system&#39;, systemonly=True)
        bibbox_logger.info(&#39;Starting nginx container&#39;)
        
        process = subprocess.Popen([&#39;docker-compose&#39;,&#39;-f&#39;, &#39;/opt/bibbox/sys-bibbox/docker-compose.yml&#39;, &#39;up&#39;, &#39;-d&#39;], stdout=subprocess.PIPE, stderr=subprocess.STDOUT)
        output, error = process.communicate()
        if output:
            output = output.decode(&#39;utf8&#39;)
            output = output.strip()
            bibbox_logger.error(output)

    def stopNginx(self, JobID):
        &#39;&#39;&#39;
        Description:
        -----------
        Stops the nginx proxy of the bibbox system.

        Parameters:
        ----------

        jobID : str
            Unique JobID that consists of an uuid and the datetime

        
        Raises:
        -------

        Returns:
        -------
        
        &#39;&#39;&#39;
        bibbox_logger = AppController.setUpLog(self, JobID, &#39;system&#39;, systemonly=True)
        bibbox_logger.info(&#39;Stopping nginx container&#39;)
        
        process = subprocess.Popen([&#39;docker-compose&#39;,&#39;-f&#39;, &#39;/opt/bibbox/sys-bibbox/docker-compose.yml&#39;, &#39;down&#39;], stdout=subprocess.PIPE, stderr=subprocess.STDOUT)
        output, error = process.communicate()
        if output:
            output = output.decode(&#39;utf8&#39;)
            output = output.strip()
            bibbox_logger.error(output)


    


    def getParams(self, instanceName, appName, version):
        &#39;&#39;&#39;
        Description:
        -----------
        Reads the user parameters of an app.

        Parameters:
        ----------

        instanceName : str
            The instance name of the application that is used 

        appName: str
            Name of the wanted app

        version: str
            Version of the wanted app
        
        Raises:
        -------

        Returns:
        -------
        paramList: array
            List of all userparameters
        
        &#39;&#39;&#39;
        try:
            url = &#39;https://raw.githubusercontent.com/bibbox/&#39; + appName + &#39;/master/.env&#39;
            download = requests.get(url).content
        except Exception:
            raise Exception(&#39;Something went wrong during connecting to the GitHub repository. Please Check your internet connection!&#39;)
        data=download.decode(&#39;utf-8&#39;)
        params = data.split(&#39;\n&#39;)
        paramList = {}
        for line in params:
            params = line.split(&#39;=&#39;)
            param = params[0]
            if param == &#39;PORT&#39; or param == &#39;&#39; or param == &#39;INSTANCE&#39;:
                pass
            else:
                paramList[param] = []
            
        return paramList, instanceName, appName, version

    def setParams(self, paramList):
        &#39;&#39;&#39;
        Description:
        -----------
        Reads the user parameters of an app.

        Parameters:
        ----------
        paramList: array
            List of all userparameters

        Raises:
        -------

        Returns:
        -------
        &#39;&#39;&#39;
        for key in paramList:
            paramList[key] = &#39;seeddms&#39;

        return paramList


    def changeSettings(self, jobID, instanceName):
        &#39;&#39;&#39;
        Description:
        -----------
        Looks for config files of an app and changes them to use the app container as sub url.

        Parameters:
        ----------
        Job ID : str
            Unique JobID that consists of an uuid and the datetime

        instanceName : str
            The instance name of the application that is used 


        
        Raises:
        -------

        Returns:
        -------
        
        &#39;&#39;&#39;

        app_logger, bibbox_logger, docker_logger, app_errorlogger = AppController.setUpLog(self, jobID, instanceName)
        app_logger.info( &#39;Change setting files&#39;)
        rootdir = dirname(dirname(abspath(__file__)))
        settingsPath = rootdir + &#39;/application-instance/&#39; + instanceName + &#39;/repo/config/&#39;
        if path.exists(settingsPath) == True:
            for filename in os.listdir(settingsPath):
                try:
                    with open(settingsPath + filename) as template:
                        file_content = template.read()
                        file_content = file_content.replace(&#34;§§INSTANCENAME&#34;, instanceName)    
                        template = open( settingsPath + filename, &#39;w+&#39;)
                        template.write(file_content)
                        template.close()
                except:
                    pass

        entrypointPath = rootdir + &#39;/application-instance/&#39; + instanceName + &#39;/repo/entrypoint.sh&#39;

        try:
            with open(entrypointPath) as template:
                file_content = template.read()
                file_content = file_content.replace(&#34;§§INSTANCENAME&#34;, instanceName)
                template = open( entrypointPath, &#39;w+&#39;)
                template.write(file_content)
                template.close()
        except Exception:
            pass</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="helperFunctions.AppController.changeCompose"><code class="name flex">
<span>def <span class="ident">changeCompose</span></span>(<span>self, jobID, instanceName, newName)</span>
</code></dt>
<dd>
<div class="desc"><h2 id="description">Description:</h2>
<p>Reads the file STATUS to get the currend state of an application and checks, if the status is allowed for the wanted operation.</p>
<h2 id="parameters">Parameters:</h2>
<p>Job ID : str
Unique JobID that consists of an uuid and the datetime</p>
<p>paramList: array
list of environment variables that are defined in the .env file in the repository of the application</p>
<p>instanceName : str
The instance name of the application that is used </p>
<p>newName: str
new instance name name of copied application</p>
<h2 id="raises">Raises:</h2>
<h2 id="returns">Returns:</h2></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def changeCompose(self, jobID, instanceName, newName):
    &#39;&#39;&#39;
    Description:
    -----------
    Reads the file STATUS to get the currend state of an application and checks, if the status is allowed for the wanted operation.

    Parameters:
    ----------
    Job ID : str
        Unique JobID that consists of an uuid and the datetime

    paramList: array
        list of environment variables that are defined in the .env file in the repository of the application

    instanceName : str
        The instance name of the application that is used 

    newName: str
        new instance name name of copied application
    
    Raises:
    -------

    Returns:
    -------
    
    &#39;&#39;&#39;

    app_logger, bibbox_logger, docker_logger, app_errorlogger = AppController.setUpLog(self, jobID, instanceName)
    app_logger.info( &#39;Write parameters to compose file&#39;)
    rootdir = dirname(dirname(abspath(__file__)))
    appPath = rootdir + &#39;/application-instance/&#39; + instanceName + &#39;/repo/&#39;
    if path.exists(appPath) == False:
        app_errorlogger.error(&#39; The folder of the app repository does not exist!&#39;)
    newAppPath = rootdir + &#39;/application-instance/&#39; + newName + &#39;/repo/&#39;
    try:
        compose = open(appPath + &#39;/docker-compose-template.yml&#39;, &#39;r&#39;)
    except Exception:
        app_errorlogger.exception(&#39;Fatal error in reading compose file: &#39;, exc_info=True)
    try:
        compose = yaml.load(compose)
        services = compose[&#39;services&#39;]
    except Exception:
        app_errorlogger.exception(&#39;Fatal error in reading compose file: &#39;, exc_info=True)
    try:
        for service in services:
            name = services[service][&#39;container_name&#39;]
            newContainerName = name.replace(instanceName, newName)
            services[service][&#39;container_name&#39;] = newContainerName
            try:
                name = services[service][&#39;links&#39;]
                newContainerName = name[0].replace(instanceName, newName)
                services[service][&#39;links&#39;] = [newContainerName]
            except:
                pass
            try:
                name = services[service][&#39;depends_on&#39;]
                newContainerName = name[0].replace(instanceName, newName)
                services[service][&#39;depends_on&#39;] = [newContainerName]
            except:
                pass
    except Exception:
        app_errorlogger.exception(&#39;Fatal error in reading compose file: &#39;, exc_info=True)
    try:    
        composenew = copy.deepcopy(compose)
    except Exception:
        app_errorlogger.exception(&#39;Fatal error while copying compose file: &#39;, exc_info=True)
    try:
        for service in services:
            newServiceName = service.replace(instanceName, newName)           
            composenew[&#39;services&#39;][newServiceName] = composenew[&#39;services&#39;][service]
            del composenew[&#39;services&#39;][service]
    except Exception:
        app_errorlogger.exception(&#39;Fatal error while writing to compose file: &#39;, exc_info=True)
    try:
        composefile = yaml.dump(composenew)
        os.system(&#39;sudo chmod -R 777 &#39; + newAppPath)
        target = open(newAppPath + &#39;docker-compose-template.yml&#39;, &#39;w&#39;)
        target.write(composefile)
        target.close()
    except Exception:
        app_errorlogger.exception(&#39;Fatal error while writing to compose file: &#39;, exc_info=True)</code></pre>
</details>
</dd>
<dt id="helperFunctions.AppController.changeInfo"><code class="name flex">
<span>def <span class="ident">changeInfo</span></span>(<span>self, jobID, instanceName, newName)</span>
</code></dt>
<dd>
<div class="desc"><h2 id="description">Description:</h2>
<p>Creates a file named INFO where install information is stored.</p>
<h2 id="parameters">Parameters:</h2>
<p>Job ID : str
Unique JobID that consists of an uuid and the datetime</p>
<p>instanceName : str
The instance name of the application that is used </p>
<p>appName : str
The (github) name of the application that is used </p>
<p>version : str
The wanted version of the application that is used </p>
<h2 id="raises">Raises:</h2>
<h2 id="returns">Returns:</h2></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def changeInfo(self, jobID, instanceName, newName):
    &#39;&#39;&#39;
    Description:
    -----------
    Creates a file named INFO where install information is stored.

    Parameters:
    ----------
    Job ID : str
        Unique JobID that consists of an uuid and the datetime

    instanceName : str
        The instance name of the application that is used 

    appName : str
        The (github) name of the application that is used 

    version : str
        The wanted version of the application that is used 
    
    Raises:
    -------

    Returns:
    -------
    
    &#39;&#39;&#39;

    app_logger, bibbox_logger, docker_logger, app_errorlogger = AppController.setUpLog(self, jobID, instanceName)
    app_logger.info( &#39;Set install info&#39;)
    rootdir = dirname(dirname(abspath(__file__)))
    appPath = rootdir + &#39;/application-instance&#39;
    if path.exists(appPath) == False:
        raise Exception(&#39;The folder &#34;/application-instance&#34; does not exist!&#39;)
    try:
        with open(appPath + &#39;/&#39; + instanceName + &#39;/info.json&#39;) as outfile:
            data = json.load(outfile)
            data[&#39;instanceName&#39;] = newName
            data[&#39;jobID&#39;] = jobID
    except Exception:
            app_errorlogger.exception(&#39;Could not open file &#34;info.json&#34; in application folder! &#39;, exc_info=True)
            raise Exception(&#39;Could not open file &#34;info.json&#34; in application folder! &#39;)
    try:
        with open(appPath + &#39;/&#39; + newName + &#39;/info.json&#39;, &#39;w+&#39;) as outfile:
            json.dump(data, outfile)
    except Exception:
            app_errorlogger.exception(&#39;Could not open file &#34;info.json&#34; in application folder! &#39;, exc_info=True)
            raise Exception(&#39;Could not write to file &#34;info.json&#34; in application folder! &#39;)</code></pre>
</details>
</dd>
<dt id="helperFunctions.AppController.changeSettings"><code class="name flex">
<span>def <span class="ident">changeSettings</span></span>(<span>self, jobID, instanceName)</span>
</code></dt>
<dd>
<div class="desc"><h2 id="description">Description:</h2>
<p>Looks for config files of an app and changes them to use the app container as sub url.</p>
<h2 id="parameters">Parameters:</h2>
<p>Job ID : str
Unique JobID that consists of an uuid and the datetime</p>
<p>instanceName : str
The instance name of the application that is used </p>
<h2 id="raises">Raises:</h2>
<h2 id="returns">Returns:</h2></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def changeSettings(self, jobID, instanceName):
    &#39;&#39;&#39;
    Description:
    -----------
    Looks for config files of an app and changes them to use the app container as sub url.

    Parameters:
    ----------
    Job ID : str
        Unique JobID that consists of an uuid and the datetime

    instanceName : str
        The instance name of the application that is used 


    
    Raises:
    -------

    Returns:
    -------
    
    &#39;&#39;&#39;

    app_logger, bibbox_logger, docker_logger, app_errorlogger = AppController.setUpLog(self, jobID, instanceName)
    app_logger.info( &#39;Change setting files&#39;)
    rootdir = dirname(dirname(abspath(__file__)))
    settingsPath = rootdir + &#39;/application-instance/&#39; + instanceName + &#39;/repo/config/&#39;
    if path.exists(settingsPath) == True:
        for filename in os.listdir(settingsPath):
            try:
                with open(settingsPath + filename) as template:
                    file_content = template.read()
                    file_content = file_content.replace(&#34;§§INSTANCENAME&#34;, instanceName)    
                    template = open( settingsPath + filename, &#39;w+&#39;)
                    template.write(file_content)
                    template.close()
            except:
                pass

    entrypointPath = rootdir + &#39;/application-instance/&#39; + instanceName + &#39;/repo/entrypoint.sh&#39;

    try:
        with open(entrypointPath) as template:
            file_content = template.read()
            file_content = file_content.replace(&#34;§§INSTANCENAME&#34;, instanceName)
            template = open( entrypointPath, &#39;w+&#39;)
            template.write(file_content)
            template.close()
    except Exception:
        pass</code></pre>
</details>
</dd>
<dt id="helperFunctions.AppController.checkDockerState"><code class="name flex">
<span>def <span class="ident">checkDockerState</span></span>(<span>self, jobID, instanceName, containerNames, allowedStates)</span>
</code></dt>
<dd>
<div class="desc"><h2 id="description">Description:</h2>
<p>Ckecks the states of all containers of an app.</p>
<h2 id="parameters">Parameters:</h2>
<p>jobID : str
Unique JobID that consists of an uuid and the datetime</p>
<p>instanceName : str
The instance name of the application that is used </p>
<p>containerNames: array
list of used containers</p>
<h2 id="raises">Raises:</h2>
<h2 id="returns">Returns:</h2></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def checkDockerState(self, jobID, instanceName, containerNames, allowedStates):
    &#39;&#39;&#39;
    Description:
    -----------
    Ckecks the states of all containers of an app.

    Parameters:
    ----------

    jobID : str
        Unique JobID that consists of an uuid and the datetime

    instanceName : str
        The instance name of the application that is used 

    containerNames: array
        list of used containers
    
    Raises:
    -------

    Returns:
    -------
    
    &#39;&#39;&#39;
    app_logger, bibbox_logger, docker_logger, app_errorlogger = AppController.setUpLog(self, jobID, instanceName)
    app_logger.info(&#39;Checking states of all containers of app: &#39; + instanceName)
    states = {}
    for name in containerNames:
        process = subprocess.Popen([&#39;docker&#39;, &#39;container&#39;, &#39;inspect&#39;, name], stdout=subprocess.PIPE, stderr=subprocess.STDOUT)
        output, error = process.communicate()
        try:
            params = simplejson.loads(output)
            status = params[0][&#39;State&#39;][&#39;Status&#39;]
            states[name] = status
        except Exception:
            app_errorlogger.exception(&#39;Could not load status of wanted container. &#39; + name + &#39; Maybe this container got removed manually. Please look at the log files!&#39;, exc_info=True)
            raise Exception(&#39;Could not load status of wanted container &#39; + name + &#39; Maybe this container got removed manually. Please look at the log files!&#39;)
        if &#39;all&#39; in allowedStates:
            pass
        else:
            if status not in allowedStates:
                app_errorlogger.error(&#39;Could not perform the wanted task. The allowed states of the app containers are: &#34;&#39; + &#39;, &#39;.join([str(elem) for elem in allowedStates]) + &#39;&#34;. But the container of app &#39; + instanceName + &#39; has state &#39; + status + &#39;.&#39;)
                raise Exception(&#39;Could not perform the wanted task. The allowed states of the app containers are: &#39; + &#39;, &#34;&#39;.join([str(elem) for elem in allowedStates]) + &#39;&#34;. But the container of app &#39; + instanceName + &#39; has state &#39; + status + &#39;.&#39;)

    return states</code></pre>
</details>
</dd>
<dt id="helperFunctions.AppController.checkExists"><code class="name flex">
<span>def <span class="ident">checkExists</span></span>(<span>self, jobID, instanceName, install)</span>
</code></dt>
<dd>
<div class="desc"><h2 id="description">Description:</h2>
<p>Checks if an app with the wanted name does already exist.</p>
<h2 id="parameters">Parameters:</h2>
<p>Job ID : str
Unique JobID that consists of an uuid and the datetime</p>
<p>instanceName : str
The instance name of the application that is used </p>
<p>install: bool
Is the method performed during Installation?
For installation, its necessary that the app does not exist,
but for start, stop, coppy &hellip; of an app it is important that the app already exists.</p>
<h2 id="raises">Raises:</h2>
<p>if install == True:</p>
<pre><code>if exists == True

    raise Exception('The app you want to install does already exist!')
</code></pre>
<p>if install == False:</p>
<pre><code>if exists == False:

    raise Exception('The app you want to use does not exist!')
</code></pre>
<h2 id="returns">Returns:</h2></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def checkExists(self, jobID, instanceName, install):
    &#39;&#39;&#39;
    Description:
    -----------
    Checks if an app with the wanted name does already exist.

    Parameters:
    ----------
    Job ID : str
        Unique JobID that consists of an uuid and the datetime

    instanceName : str
        The instance name of the application that is used 

    install: bool
        Is the method performed during Installation?
        For installation, its necessary that the app does not exist, 
        but for start, stop, coppy ... of an app it is important that the app already exists.

    Raises:
    -------
    if install == True:

        if exists == True

            raise Exception(&#39;The app you want to install does already exist!&#39;)

    if install == False:

        if exists == False:

            raise Exception(&#39;The app you want to use does not exist!&#39;)

    Returns:
    -------
    
    &#39;&#39;&#39;
    rootdir = dirname(dirname(abspath(__file__)))
    bibbox_logger = AppController.setUpLog(self, jobID, instanceName, systemonly=True)
    appPath = rootdir + &#39;/application-instance/&#39;
    bibbox_logger.info(&#39;Check if app folder exists&#39;)
    if path.exists(appPath) == False:
        process = subprocess.Popen([&#39;mkdir&#39;, appPath])
        output, error = process.communicate()
        if output:
            bibbox_logger.debug( str(output))
    if instanceName in os.listdir(appPath):
        exists = True
    else:
        exists = False
    if install == True:
        if exists == True:
            bibbox_logger.info(&#39;The app you want to install does already exist! App: &#39; + instanceName)
            raise Exception(&#39;The app you want to install does already exist! App: &#39; + instanceName)
    if install == False:
        if exists == False:
            bibbox_logger.info(&#39;The app you want to use does not exist! App: &#39; + instanceName)
            raise Exception(&#39;The app you want to use does not exist! App: &#39; + instanceName)</code></pre>
</details>
</dd>
<dt id="helperFunctions.AppController.checkInput"><code class="name flex">
<span>def <span class="ident">checkInput</span></span>(<span>self, jobID, instanceName, inputparams)</span>
</code></dt>
<dd>
<div class="desc"><h2 id="description">Description:</h2>
<p>Ckecks if the userinput is valid.</p>
<h2 id="parameters">Parameters:</h2>
<p>jobID : str
Unique JobID that consists of an uuid and the datetime</p>
<p>instanceName : str
The instance name of the application that is used </p>
<p>input: array
List of used parameters to check</p>
<h2 id="raises">Raises:</h2>
<h2 id="returns">Returns:</h2></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def checkInput(self, jobID, instanceName, inputparams):
    &#39;&#39;&#39;
    Description:
    -----------
    Ckecks if the userinput is valid.

    Parameters:
    ----------

    jobID : str
        Unique JobID that consists of an uuid and the datetime

    instanceName : str
        The instance name of the application that is used 

    input: array
        List of used parameters to check
    
    Raises:
    -------

    Returns:
    -------
    
    &#39;&#39;&#39;
    bibbox_logger = AppController.setUpLog(self, jobID, instanceName, systemonly = True)
    if type(instanceName) != str:
        bibbox_logger.debug(&#39;The input &#39; + instanceName + &#39; is not valid! Must be a string, but has type &#39; + type(instanceName) + &#39;!&#39;)
    validAll = True
    if not inputparams:
        bibbox_logger.info(&#39;There are no input parameters to check&#39;)
    for var in inputparams:
        valid = bool(re.match(&#39;^[a-zA-Z0-9\-]*$&#39;,var))
        negativeList = [&#39;admin&#39;]
        for param in negativeList:
            if param in var:
                validAll = False
                bibbox_logger.debug(&#39;The input &#39; + var + &#39; is not valid!&#39;)
        if valid == False:
            validAll = False
            bibbox_logger.debug(&#39;The input &#39; + var + &#39; is not valid!&#39;)

    if validAll == True:
        bibbox_logger.debug(&#39;The tested input is valid!&#39;)
    if validAll == False:
        bibbox_logger.debug(&#39;The tested input is not valid!&#39;)

    return validAll</code></pre>
</details>
</dd>
<dt id="helperFunctions.AppController.checkInstall"><code class="name flex">
<span>def <span class="ident">checkInstall</span></span>(<span>self, jobID, instanceName, states)</span>
</code></dt>
<dd>
<div class="desc"><h2 id="description">Description:</h2>
<p>After the installation of an app, this function checks if the installation was sucessfull and the app is running.</p>
<h2 id="parameters">Parameters:</h2>
<p>jobID : str
Unique JobID that consists of an uuid and the datetime</p>
<p>instanceName : str
The instance name of the application that is used </p>
<p>states: json Object
List of installed containers and their corresponding state</p>
<h2 id="raises">Raises:</h2>
<h2 id="returns">Returns:</h2></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def checkInstall(self, jobID, instanceName, states):
    &#39;&#39;&#39;
    Description:
    -----------
    After the installation of an app, this function checks if the installation was sucessfull and the app is running.

    Parameters:
    ----------

    jobID : str
        Unique JobID that consists of an uuid and the datetime

    instanceName : str
        The instance name of the application that is used 

    states: json Object
        List of installed containers and their corresponding state
    
    Raises:
    -------

    Returns:
    -------
    
    &#39;&#39;&#39;
    app_logger, bibbox_logger, docker_logger, app_errorlogger = AppController.setUpLog(self, jobID, instanceName)
    app_logger.info(&#39;Checking if installation of app &#39; + instanceName + &#39; was successful!&#39;)
    for container in states:
        state = states[container]
        if state != &#39;running&#39;:
            try: 
                AppController.startApp(self, instanceName)
            except:
                pass
        if state != &#39;running&#39;:
            AppController.removeApp(self, instancename)
            app_logger.error(&#39;The installation could not be completed. Please read the logs and try again&#39;)</code></pre>
</details>
</dd>
<dt id="helperFunctions.AppController.checkProxy"><code class="name flex">
<span>def <span class="ident">checkProxy</span></span>(<span>self, containerName)</span>
</code></dt>
<dd>
<div class="desc"><h2 id="description">Description:</h2>
<p>Ckecks the state of the proxy container.</p>
<h2 id="parameters">Parameters:</h2>
<p>containerNames: array
list of used containers</p>
<h2 id="raises">Raises:</h2>
<h2 id="returns">Returns:</h2></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def checkProxy(self, containerName):
    &#39;&#39;&#39;
    Description:
    -----------
    Ckecks the state of the proxy container.

    Parameters:
    ----------

    containerNames: array
        list of used containers
    
    Raises:
    -------

    Returns:
    -------
    
    &#39;&#39;&#39;
    bibbox_logger = AppController.setUpLog(self, &#39;system check&#39;, &#39;system &#39;, systemonly=True)
    bibbox_logger.info(&#39;Performing proxy check!&#39;)
    states = {}
    process = subprocess.Popen([&#39;docker&#39;, &#39;container&#39;, &#39;inspect&#39;, containerName], stdout=subprocess.PIPE, stderr=subprocess.STDOUT)
    output, error = process.communicate()
    state = &#39;&#39;
    try:
        params = simplejson.loads(output)
        state = params[0][&#39;State&#39;][&#39;Status&#39;]
    
        
        if state == &#39;running&#39;:
             bibbox_logger.info(&#39;The nginx Container is running. \n Everything OK.&#39;)
        else:
             bibbox_logger.error(&#39;The nginx Container is not running. \n Please try to restart the bibbox System.&#39;)
    except:
         bibbox_logger.error(&#39;The nginx Container is not running. \n Please try to restart the bibbox System with &#34;bibbox restartSystem&#34;.&#39;)

    return state</code></pre>
</details>
</dd>
<dt id="helperFunctions.AppController.checkStatus"><code class="name flex">
<span>def <span class="ident">checkStatus</span></span>(<span>self, jobID, instanceName, statusList)</span>
</code></dt>
<dd>
<div class="desc"><h2 id="description">Description:</h2>
<p>Reads the file STATUS to get the currend state of an application and checks, if the status is allowed for the wanted operation.</p>
<h2 id="parameters">Parameters:</h2>
<p>Job ID : str
Unique JobID that consists of an uuid and the datetime</p>
<p>instanceName : str
The instance name of the application that is used </p>
<p>statusList: array
List of states, that allow a specific operation on an application</p>
<h2 id="raises">Raises:</h2>
<p>raise Exception('Current app status does not allow your operation!') if the currend status is not in the statuslist</p>
<h2 id="returns">Returns:</h2></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def checkStatus(self, jobID, instanceName, statusList):
    &#39;&#39;&#39;
    Description:
    -----------
    Reads the file STATUS to get the currend state of an application and checks, if the status is allowed for the wanted operation.

    Parameters:
    ----------
    Job ID : str
        Unique JobID that consists of an uuid and the datetime

    instanceName : str
        The instance name of the application that is used 

    statusList: array
        List of states, that allow a specific operation on an application
    
    Raises:
    -------
    raise Exception(&#39;Current app status does not allow your operation!&#39;) if the currend status is not in the statuslist

    Returns:
    -------
    
    &#39;&#39;&#39;

    app_logger, bibbox_logger, docker_logger, app_errorlogger = AppController.setUpLog(self, jobID, instanceName)
    app_logger.info( &#39;Checking if operation is possible for current state of app: &#39; + instanceName)
    rootdir = dirname(dirname(abspath(__file__)))
    appPath = rootdir + &#39;/application-instance/&#39; + instanceName + &#39;/&#39;
    if path.exists(appPath) == False:
        app_errorlogger.debug(&#39;The folder of the app repository does not exist!&#39;)
    try:
        with open(appPath + &#39;STATUS&#39;) as statusfile:
            file_content = statusfile.read()
            
    except Exception:
        logging.exception(&#39;Could not open STATUS file: &#39;, exc_info=True)
    if file_content not in statusList:
        app_errorlogger.exception(&#39;Current app status does not allow operation on app: &#39; + instanceName)
        raise Exception(&#39;Current app status does not allow your operation!&#39;)</code></pre>
</details>
</dd>
<dt id="helperFunctions.AppController.checkSystem"><code class="name flex">
<span>def <span class="ident">checkSystem</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><h2 id="description">Description:</h2>
<p>System Check. Checks the versions of the required packages.</p>
<h2 id="parameters">Parameters:</h2>
<p>containerNames: array
list of used containers</p>
<h2 id="raises">Raises:</h2>
<h2 id="returns">Returns:</h2></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def checkSystem(self):
    &#39;&#39;&#39;
    Description:
    -----------
    System Check. Checks the versions of the required packages.

    Parameters:
    ----------

    containerNames: array
        list of used containers
    
    Raises:
    -------

    Returns:
    -------
    
    &#39;&#39;&#39;

    bibbox_logger = AppController.setUpLog(self, &#39;system check&#39;, &#39;system &#39;, systemonly=True)
    bibbox_logger.info(&#39;Performing system check!&#39;)

    if float(str(sys.version_info[0]) + &#39;.&#39; + str(sys.version_info[1])) &gt; 3.5:
        bibbox_logger.info(&#39;Python Version: &#39; + str(sys.version_info[0]) + &#39;.&#39; + str(sys.version_info[1]) + &#39; ---&gt; OK!&#39;)
    else:
        bibbox_logger.error(&#39;You are using a Python version below 3.5 or do not have Python installed. Please install Python 3.5+!&#39;)
        bibbox_logger.error(output)

    process = subprocess.Popen([&#39;docker&#39;, &#39;version&#39;, &#39;--format&#39;, &#39;{{.Server.Version}}&#39;], stdout=subprocess.PIPE, stderr=subprocess.STDOUT)
    output, error = process.communicate()
    output = output.decode(&#39;utf-8&#39;)
    if version.parse(output) &gt; version.parse(&#34;19.03.00&#34;):
        bibbox_logger.info(&#39;Docker Version: &#39; + output + &#39; ---&gt; OK!&#39;)
    else:
        bibbox_logger.error(&#39;You are using a Docker Engine version below 19.03.0 or do not have Docker Engine installed. Please install Docker Engine 19.03.0+!&#39;)
        bibbox_logger.error(output)

    process = subprocess.Popen([&#39;docker-compose&#39;, &#39;version&#39;,  &#39;--short&#39;], stdout=subprocess.PIPE, stderr=subprocess.STDOUT)
    output, error = process.communicate()
    output = output.decode(&#39;utf8&#39;)
    
    if version.parse(str(output)) &gt; version.parse(&#34;1.26.0&#34;):
        bibbox_logger.info(&#39;Docker-Compose Version: &#39; + output + &#39; ---&gt;  OK!&#39;)
    else:
        bibbox_logger.error(&#39;You are using a Docker Compose version below 1.26.0 or do not have Docker Compose installed. Please install Docker Compose 1.26.0+!&#39;)
        bibbox_logger.error(output)

    process = subprocess.Popen([&#39;docker&#39;, &#39;network&#39;, &#39;create&#39;, &#39;bibbox-default-network&#39;], stdout=subprocess.PIPE, stderr=subprocess.STDOUT)
    output, error = process.communicate()
    output = output.decode(&#39;utf8&#39;)
    if output:
        bibbox_logger.debug(&#39;Creating default network:&#39; + output)

    bibbox_logger.info(&#39;Check internet connection&#39;)
    try:
        requests.get(&#39;http://216.58.192.142&#39;, timeout=1)
        bibbox_logger.debug(&#39;Internet connection ---&gt; OK&#39;)
    except: 
        bibbox_logger.error(&#39;Can not connect to the internet!&#39;)</code></pre>
</details>
</dd>
<dt id="helperFunctions.AppController.composeUp"><code class="name flex">
<span>def <span class="ident">composeUp</span></span>(<span>self, jobID, instanceName, containerName)</span>
</code></dt>
<dd>
<div class="desc"><h2 id="description">Description:</h2>
<p>Executes the doker-compose up command and starts the application</p>
<h2 id="parameters">Parameters:</h2>
<p>Job ID : str
Unique JobID that consists of an uuid and the datetime</p>
<p>instanceName : str
The instance name of the application that is used </p>
<h2 id="raises">Raises:</h2>
<h2 id="returns">Returns:</h2></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def composeUp(self, jobID, instanceName, containerName):
    &#39;&#39;&#39;
    Description:
    -----------
    Executes the doker-compose up command and starts the application

    Parameters:
    ----------
    Job ID : str
        Unique JobID that consists of an uuid and the datetime

    instanceName : str
        The instance name of the application that is used 
    
    Raises:
    -------

    Returns:
    -------
    &#39;&#39;&#39;

    app_logger, bibbox_logger, docker_logger, app_errorlogger = AppController.setUpLog(self, jobID, instanceName)
    app_logger.info( &#39;Docker compose up&#39;)
    rootdir = dirname(dirname(abspath(__file__)))
    appPath = rootdir + &#39;/application-instance/&#39; + instanceName + &#39;/repo/&#39;
    if path.exists(appPath) == False:
        raise Exception(&#39;The folder &#34;/application-instance&#34; does not exist!&#39;)
    process = subprocess.Popen([&#39;docker-compose&#39;, &#39;-f&#39;, appPath + &#39;/docker-compose-template.yml&#39;, &#39;up&#39;, &#39;-d&#39;], stdout=subprocess.PIPE, stderr=subprocess.STDOUT, encoding=&#34;utf8&#34;)
    output, error = process.communicate()
    if output:
        docker_logger.error( str(output).rstrip())
    process = subprocess.Popen([&#39;docker&#39;, &#39;exec&#39;, &#39;-it&#39;, &#39;local_nginx&#39;, &#39;service&#39;, &#39;nginx&#39;, &#39;reload&#39;], stdout=subprocess.PIPE, stderr=subprocess.STDOUT, encoding=sys.stdout.encoding)
    output, error = process.communicate()
    ansi_regex = r&#39;\x1b+\[+\d+\d+;+\d+\d+[m]|&#39; \
         r&#39;\x1b(&#39; \
         r&#39;(\[\??\d+[hl])|&#39; \
         r&#39;([=&lt;&gt;a-kzmNM78])|&#39; \
         r&#39;([\(\)][a-b0-2])|&#39; \
         r&#39;(\[\d{0,2}[ma-dgkjqi])|&#39; \
         r&#39;(\[\d+;\d+[hfy]?)|&#39; \
         r&#39;(\[;?[hf])|&#39; \
         r&#39;(#[3-68])|&#39; \
         r&#39;([01356]n)|&#39; \
         r&#39;(O[mlnp-z]?)|&#39; \
         r&#39;(/Z)|&#39; \
         r&#39;(\d+)|&#39; \
         r&#39;(\[\?\d;\d0c)|&#39; \
         r&#39;(\d;\dR)|&#39; \
         r&#39;(\[*\d*\d*;*\d*\d*[m]))&#39; 
         
    ansi_escape = re.compile(ansi_regex, flags=re.IGNORECASE)
    result = ansi_escape.sub(&#39;&#39;, output).rstrip()
    if output:
        bibbox_logger.debug( str(output).rstrip())
    process = subprocess.Popen([&#39;docker&#39;, &#39;logs&#39;, containerName], stdout=subprocess.PIPE, stderr=subprocess.STDOUT, encoding=&#34;utf8&#34;)
    output, error = process.communicate()
    if output:
        docker_logger.debug( str(output).rstrip())
    try:
        process = subprocess.Popen([&#39;docker&#39;, &#39;exec&#39;, containerName, &#39;/var/entrypoint.sh&#39;], stdout=subprocess.PIPE, stderr=subprocess.STDOUT, encoding=&#34;utf8&#34;)
        output, error = process.communicate()
        if output:
            docker_logger.debug( str(output).rstrip())
    except:
        pass</code></pre>
</details>
</dd>
<dt id="helperFunctions.AppController.copy"><code class="name flex">
<span>def <span class="ident">copy</span></span>(<span>self, jobID, instanceName, newName)</span>
</code></dt>
<dd>
<div class="desc"><h2 id="description">Description:</h2>
<p>Copies the current app folder to the new app destination.</p>
<h2 id="parameters">Parameters:</h2>
<p>Job ID : str
Unique JobID that consists of an uuid and the datetime</p>
<p>instanceName: str
The instance name of the application that is used </p>
<p>newName: str
New name of the copied application</p>
<h2 id="raises">Raises:</h2>
<h2 id="returns">Returns:</h2></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def copy(self, jobID, instanceName, newName):
    &#39;&#39;&#39;
    Description:
    -----------
    Copies the current app folder to the new app destination.

    Parameters:
    ----------
    Job ID : str
        Unique JobID that consists of an uuid and the datetime

    instanceName: str
        The instance name of the application that is used 

    newName: str
        New name of the copied application
    
    Raises:
    -------

    Returns:
    -------
    
    &#39;&#39;&#39;

    app_logger, bibbox_logger, docker_logger,  app_errorlogger = AppController.setUpLog(self, jobID, instanceName)
    app_logger.info(&#39;Copy App:&#39; + instanceName)
    rootdir = dirname(dirname(abspath(__file__)))
    appPath = rootdir + &#39;/application-instance/&#39; + instanceName + &#39;/repo/&#39;
    if path.exists(appPath) == False:
        app_errorlogger.error(&#39;The folder of the app repository does not exist!&#39;)
    process = subprocess.Popen([&#39;sudo&#39;, &#39;chmod&#39;, &#39;-R&#39;, &#39;777&#39;, rootdir + &#39;/application-instance/&#39; +  instanceName], stdout=subprocess.PIPE, stderr=subprocess.STDOUT)
    output, error = process.communicate()
    if output:
        app_errorlogger.error( str(output))
    process = subprocess.Popen([&#39;cp&#39;, &#39;-r&#39;, rootdir + &#39;/application-instance/&#39; + instanceName, rootdir + &#39;/application-instance/&#39; + newName], stdout=subprocess.PIPE, stderr=subprocess.STDOUT)
    output, error = process.communicate()
    if output:
        app_errorlogger.error( str(output))</code></pre>
</details>
</dd>
<dt id="helperFunctions.AppController.createFolder"><code class="name flex">
<span>def <span class="ident">createFolder</span></span>(<span>self, jobID, instanceName)</span>
</code></dt>
<dd>
<div class="desc"><h2 id="description">Description:</h2>
<p>Creates destination folder for app repository.</p>
<h2 id="parameters">Parameters:</h2>
<p>Job ID : str
Unique JobID that consists of an uuid and the datetime</p>
<p>instanceName : str
The instance name of the application that is used </p>
<h2 id="raises">Raises:</h2>
<h2 id="returns">Returns:</h2></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def createFolder(self, jobID, instanceName):
    &#39;&#39;&#39;
    Description:
    -----------
    Creates destination folder for app repository.

    Parameters:
    ----------
    Job ID : str
        Unique JobID that consists of an uuid and the datetime

    instanceName : str
        The instance name of the application that is used 
    
    Raises:
    -------
    

    Returns:
    -------
    
    &#39;&#39;&#39;
    bibbox_logger = AppController.setUpLog(self, jobID, instanceName, systemonly=True)
    bibbox_logger.info(&#39;Check if app folder exists&#39;)
    rootdir = dirname(dirname(abspath(__file__)))
    appPath = rootdir + &#39;/application-instance&#39;
    if path.exists(appPath) == False:
        bibbox_logger.error( &#39;Error While creating folder for application &#39; + instanceName + &#39;. The folder &#34;/application-instance&#34; does not exist!&#39;)
        raise Exception(&#39;Error While creating folder for application &#39; + instanceName + &#39;. The folder &#34;/application-instance&#34; does not exist!&#39;)
    process = subprocess.Popen([&#39;mkdir&#39; , appPath + &#39;/&#39; + instanceName])
    output, error = process.communicate()
    if output:
        bibbox_logger.debug( str(output))
    process = subprocess.Popen([&#39;mkdir&#39; , appPath + &#39;/&#39; + instanceName + &#39;/log/&#39;])
    output, error = process.communicate()
    if output:
        bibbox_logger.debug( str(output))
    if path.exists(appPath + &#39;/&#39; + instanceName) == False:
        bibbox_logger.error( &#39;Error While creating folder for application &#39; + instanceName + &#39;. The folder &#34;/application-instance/&#39; + instanceName + &#39;/&#34; does not exist!&#39;)
        raise Exception(&#39;Error While creating folder for application &#39; + instanceName + &#39;. The folder &#34;/application-instance&#34; does not exist!&#39;)
    if path.exists(appPath + &#39;/&#39; + instanceName + &#39;/log/&#39;) == False:
        bibbox_logger.error( &#39;Error While creating folder for application &#39; + instanceName + &#39;. The folder &#34;/application-instance&#39; + instanceName + &#39;/log/&#34; does not exist!&#39;)
        raise Exception(&#39;Error While creating folder for application &#39; + instanceName + &#39;. The folder &#34;/application-instance&#34; does not exist!&#39;)</code></pre>
</details>
</dd>
<dt id="helperFunctions.AppController.createJobID"><code class="name flex">
<span>def <span class="ident">createJobID</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><h2 id="description">Description:</h2>
<p>Creates a unique JobID to be able to identify every single job.</p>
<h2 id="parameters">Parameters:</h2>
<h2 id="raises">Raises:</h2>
<h2 id="returns">Returns:</h2>
<p>Job ID : str
Unique JobID that consists of an uuid and the current datetime</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def createJobID(self):
    &#39;&#39;&#39;
    Description:
    -----------
    Creates a unique JobID to be able to identify every single job.

    Parameters:
    ----------

    Raises:
    -------
    
    Returns:
    -------
    Job ID : str
        Unique JobID that consists of an uuid and the current datetime
    &#39;&#39;&#39;
    jobID = str(uuid.uuid1())
    dateObj = datetime.now()
    datestring = str(dateObj.year) + &#39;-&#39; + str(dateObj.month) + &#39;-&#39; + str(dateObj.day) + &#39;-&#39; + str(dateObj.microsecond)
    jobID = jobID + datestring
    return jobID</code></pre>
</details>
</dd>
<dt id="helperFunctions.AppController.downloadApp"><code class="name flex">
<span>def <span class="ident">downloadApp</span></span>(<span>self, jobID, instanceName, appName, version='master')</span>
</code></dt>
<dd>
<div class="desc"><h2 id="description">Description:</h2>
<p>Downloads the wanted app from Github before installation.</p>
<h2 id="parameters">Parameters:</h2>
<p>Job ID : str
Unique JobID that consists of an uuid and the datetime</p>
<p>instanceName : str
The instance name of the application that is used </p>
<p>appName : str
The (github) name of the application that is used </p>
<p>version : str
The wanted version of the application that is used </p>
<h2 id="raises">Raises:</h2>
<h2 id="returns">Returns:</h2></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def downloadApp(self, jobID, instanceName,appName,version = &#39;master&#39;):
    &#39;&#39;&#39;
    Description:
    -----------
    Downloads the wanted app from Github before installation.

    Parameters:
    ----------
    Job ID : str
        Unique JobID that consists of an uuid and the datetime

    instanceName : str
        The instance name of the application that is used 

    appName : str
        The (github) name of the application that is used 

    version : str
        The wanted version of the application that is used 
    
    Raises:
    -------

    Returns:
    -------
    
    &#39;&#39;&#39;
    if version == &#39;&#39; or version == None:
        version = &#39;master&#39;
    bibbox_logger = AppController.setUpLog(self, jobID, &#39;system&#39;, systemonly=True)
    try:
        url = &#39;https://raw.githubusercontent.com/bibbox/application-store/master/bibboxV4.json&#39;
        download = requests.get(url).content
    except Exception:
        raise Exception(&#39;Something went wrong during connecting to the GitHub repository. Please Check your internet connection!&#39;)
    try:
        params = simplejson.loads(download)
    except Exception:
        bibbox_logger.exception(&#39;Error while loading bibboxV4.json file: &#39;, exc_info=True)
        raise Exception(&#39;Error while loading bibboxV4.json file&#39;)
    appslist=[]
    
    appNameNew = &#39;app-&#39;+ appName     
    rootdir = dirname(dirname(abspath(__file__)))
    print(rootdir)
    #rootdir = &#39;opt/bibbox/sys-bibbox&#39;
    appPath = rootdir + &#39;/application-instance&#39;
    if path.exists(appPath) == False:
        raise Exception(&#39;The folder &#34;/application-instance&#34; does not exist!&#39;)
    app_logger, bibbox_logger, docker_logger, app_errorlogger = AppController.setUpLog(self, jobID, instanceName)
    app_logger.info( &#39;Downloading app: &#39; + appNameNew + &#39;/&#39; + instanceName + &#39; V:&#39; + version)
    
    process = subprocess.Popen([&#39;git&#39;, &#39;clone&#39;,&#39;-b&#39;, version, &#39;https://github.com/bibbox/&#39; + appNameNew + &#39;.git&#39;, rootdir + &#39;/application-instance/&#39; + instanceName + &#39;/repo/&#39;],text=True, stdout=subprocess.PIPE, stderr=subprocess.STDOUT)
    output, error = process.communicate()
    if output:
        app_logger.debug(str(output).rstrip() )
    if path.exists(appPath + &#39;/&#39; + instanceName + &#39;/repo&#39;) == False:
        app_errorlogger.exception(&#39;Something went wrong during downloading app: &#39; + instanceName, exc_info=True)
        raise Exception(&#39;Fatal error in during downloading app: &#39; + instanceName)</code></pre>
</details>
</dd>
<dt id="helperFunctions.AppController.getAppName"><code class="name flex">
<span>def <span class="ident">getAppName</span></span>(<span>self, appName)</span>
</code></dt>
<dd>
<div class="desc"><h2 id="description">Description:</h2>
<p>Returns the repository name for the corresponding application.</p>
<h2 id="parameters">Parameters:</h2>
<p>Job ID : str
Unique JobID that consists of an uuid and the datetime</p>
<p>instanceName : str
The instance name of the application that is used </p>
<p>appName : str
The (github) name of the application that is used </p>
<p>version : str
The wanted version of the application that is used </p>
<h2 id="raises">Raises:</h2>
<h2 id="returns">Returns:</h2></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def getAppName(self, appName):
    &#39;&#39;&#39;
    Description:
    -----------
    Returns the repository name for the corresponding application.

    Parameters:
    ----------
    Job ID : str
        Unique JobID that consists of an uuid and the datetime

    instanceName : str
        The instance name of the application that is used 

    appName : str
        The (github) name of the application that is used 

    version : str
        The wanted version of the application that is used 
    
    Raises:
    -------

    Returns:
    -------
    
    &#39;&#39;&#39;

    try:
        url = &#39;https://raw.githubusercontent.com/bibbox/application-store/master/bibboxV4.json&#39;
        download = requests.get(url).content
    except Exception:
        raise Exception(&#39;Something went wrong during connecting to the GitHub repository. Please Check your internet connection!&#39;)
    try:
        params = simplejson.loads(download)
    except Exception:
        bibbox_logger.exception(&#39;Error while loading bibboxV4.json file: &#39;, exc_info=True)
        raise Exception(&#39;Error while loading bibboxV4.json file&#39;)
    appslist=[]
    
    appName = &#39;app-&#39;+appName
    sys.stdout.write(appName+ &#39;\n&#39;)
    
    return appName</code></pre>
</details>
</dd>
<dt id="helperFunctions.AppController.getInstalledApps"><code class="name flex">
<span>def <span class="ident">getInstalledApps</span></span>(<span>self, jobID, instanceName)</span>
</code></dt>
<dd>
<div class="desc"><h2 id="description">Description:</h2>
<p>Lists the available Apps.</p>
<h2 id="parameters">Parameters:</h2>
<h2 id="raises">Raises:</h2>
<h2 id="returns">Returns:</h2>
<p>installedAppslist: json object
The list of all installed apps as json object</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def getInstalledApps(self, jobID, instanceName):
    &#39;&#39;&#39;
    Description:
    -----------
    Lists the available Apps.

    Parameters:
    ----------

    Raises:
    -------

    Returns:
    -------
    installedAppslist: json object
        The list of all installed apps as json object
    &#39;&#39;&#39;

    bibbox_logger = AppController.setUpLog(self, jobID, instanceName, systemonly=True)
    rootdir = dirname(dirname(abspath(__file__)))
    appPath = rootdir + &#39;/application-instance/&#39; 
    if path.exists(appPath) == False:
        app_erbibbox_loggerrorlogger.error(&#39; The folder of the app repository does not exist!&#39;)
    installedApps = {}
    try:
        for i, folder in enumerate(os.listdir(appPath)):
            with open(appPath + &#39;/&#39; + folder + &#39;/info.json&#39;) as infofile:
                data = json.load(infofile)
                instanceName = data[&#39;instanceName&#39;]
                appName = data[&#39;appName&#39;]
                installedApps[instanceName] = appName
    except Exception:
            bibbox_logger.exception(&#39;Could not open file &#34;info.json&#34; in application folder! &#39;, exc_info=True)
            raise Exception(&#39;Could not open file &#34;info.json&#34; in application folder! &#39;)
            
            
    installedAppsList = json.dumps(installedApps)
    return installedAppsList</code></pre>
</details>
</dd>
<dt id="helperFunctions.AppController.getParams"><code class="name flex">
<span>def <span class="ident">getParams</span></span>(<span>self, instanceName, appName, version)</span>
</code></dt>
<dd>
<div class="desc"><h2 id="description">Description:</h2>
<p>Reads the user parameters of an app.</p>
<h2 id="parameters">Parameters:</h2>
<p>instanceName : str
The instance name of the application that is used </p>
<p>appName: str
Name of the wanted app</p>
<p>version: str
Version of the wanted app</p>
<h2 id="raises">Raises:</h2>
<h2 id="returns">Returns:</h2>
<p>paramList: array
List of all userparameters</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def getParams(self, instanceName, appName, version):
    &#39;&#39;&#39;
    Description:
    -----------
    Reads the user parameters of an app.

    Parameters:
    ----------

    instanceName : str
        The instance name of the application that is used 

    appName: str
        Name of the wanted app

    version: str
        Version of the wanted app
    
    Raises:
    -------

    Returns:
    -------
    paramList: array
        List of all userparameters
    
    &#39;&#39;&#39;
    try:
        url = &#39;https://raw.githubusercontent.com/bibbox/&#39; + appName + &#39;/master/.env&#39;
        download = requests.get(url).content
    except Exception:
        raise Exception(&#39;Something went wrong during connecting to the GitHub repository. Please Check your internet connection!&#39;)
    data=download.decode(&#39;utf-8&#39;)
    params = data.split(&#39;\n&#39;)
    paramList = {}
    for line in params:
        params = line.split(&#39;=&#39;)
        param = params[0]
        if param == &#39;PORT&#39; or param == &#39;&#39; or param == &#39;INSTANCE&#39;:
            pass
        else:
            paramList[param] = []
        
    return paramList, instanceName, appName, version</code></pre>
</details>
</dd>
<dt id="helperFunctions.AppController.lock"><code class="name flex">
<span>def <span class="ident">lock</span></span>(<span>self, jobID, instanceName)</span>
</code></dt>
<dd>
<div class="desc"><h2 id="description">Description:</h2>
<p>Creates a file named LOCK to lock an app, so that no one is able to perform other operations
on an app before the current operation is finished.</p>
<h2 id="parameters">Parameters:</h2>
<p>Job ID : str
Unique JobID that consists of an uuid and the datetime</p>
<p>instanceName : str
The instance name of the application that is used </p>
<h2 id="raises">Raises:</h2>
<p>Exception('The app you want to use is currently locked! Please try again later!') if the wanted app is currently locked.</p>
<h2 id="returns">Returns:</h2></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def lock(self, jobID, instanceName):
    &#39;&#39;&#39;
    Description:
    -----------
    Creates a file named LOCK to lock an app, so that no one is able to perform other operations
    on an app before the current operation is finished.

    Parameters:
    ----------
    Job ID : str
        Unique JobID that consists of an uuid and the datetime

    instanceName : str
        The instance name of the application that is used 
    
    Raises:
    -------
    Exception(&#39;The app you want to use is currently locked! Please try again later!&#39;) if the wanted app is currently locked.

    Returns:
    -------
    
    &#39;&#39;&#39;

    app_logger, bibbox_logger, docker_logger, app_errorlogger = AppController.setUpLog(self, jobID, instanceName)
    app_logger.info( &#39;Ckeck if app is locked&#39; )
    rootdir = dirname(dirname(abspath(__file__)))
    appPath = rootdir + &#39;/application-instance&#39;
    if path.exists(appPath) == False:
        app_errorlogger.error(&#39; - The folder &#34;/application-instance&#34; does not exist!&#39;)
    if &#39;LOCK&#39; in os.listdir(appPath + &#39;/&#39; + instanceName):
        try:
            with open(appPath + &#39;/&#39; + instanceName + &#39;/LOCK&#39;) as lockfile:
                lockID = lockfile.read()
                if lockID != jobID:
                    app_errorlogger.exception( &#39; - The app you want to use is currently locked! Please try again later!&#39;)
                    raise Exception(&#39;The app you want to use is currently locked! Please try again later!&#39;)
        except Exception:
            app_errorlogger.exception(&#39;Fatal error in writing to LOCK file: &#39;, exc_info=True)
            raise Exception(&#39;Could not open LOCK file in application folder!&#39;)

    app_logger.debug( &#39;Locking app: &#39; + instanceName )
    process = subprocess.Popen([&#39;touch&#39; , appPath + &#39;/&#39; + instanceName + &#39;/LOCK&#39;], stdout=subprocess.PIPE, stderr=subprocess.STDOUT)
    output, error = process.communicate()
    if output:
        app_errorlogger.error(str(output) )
    if path.exists(appPath + &#39;/&#39; + instanceName + &#39;/LOCK&#39;) == False:
        app_errorlogger.exception(&#39;Something went wrong during writing LOCK file: &#39;, exc_info=True)
        raise Exception(&#39;Fatal error in writing LOCK file: &#39;)</code></pre>
</details>
</dd>
<dt id="helperFunctions.AppController.readAppStore"><code class="name flex">
<span>def <span class="ident">readAppStore</span></span>(<span>self, jobID, instanceName)</span>
</code></dt>
<dd>
<div class="desc"><h2 id="description">Description:</h2>
<p>Lists the available Apps.</p>
<h2 id="parameters">Parameters:</h2>
<h2 id="raises">Raises:</h2>
<h2 id="returns">Returns:</h2>
<p>appslist: json object
The list of all available apps as json object</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def readAppStore(self, jobID, instanceName):
    &#39;&#39;&#39;
    Description:
    -----------
    Lists the available Apps.

    Parameters:
    ----------

    Raises:
    -------

    Returns:
    -------
    appslist: json object
        The list of all available apps as json object
    &#39;&#39;&#39;
    bibbox_logger = AppController.setUpLog(self, jobID, &#39;system&#39;, systemonly=True)
    try:
        url = &#39;https://raw.githubusercontent.com/bibbox/application-store/master/eB3Kit.json&#39;
        download = requests.get(url).content
    except Exception:
        raise Exception(&#39;Something went wrong during connecting to the GitHub repository. Please Check your internet connection!&#39;)
    try:
        params = simplejson.loads(download)
    except Exception:
        bibbox_logger.exception(&#39;Error while loading eB3Kit.json file: &#39;, exc_info=True)
        raise Exception(&#39;Error while loading eB3Kit.json file&#39;)
    appslist=[]
    try:
        for i, values in enumerate(params):
            variable = values[&#39;group_members&#39;]
            for i, var in enumerate(variable):
                appName = var[&#39;app_name&#39;]
                if appName not in appslist:
                    appslist.append(appName)
    except Exception:
        raise Exception(&#39;Error while loading eB3Kit.json file!&#39;)
        bibbox_logger.exception(&#39;Error while loading eB3Kit.json file: &#39;, exc_info=True)                

    return appslist</code></pre>
</details>
</dd>
<dt id="helperFunctions.AppController.readContainernames"><code class="name flex">
<span>def <span class="ident">readContainernames</span></span>(<span>self, jobID, instanceName)</span>
</code></dt>
<dd>
<div class="desc"><h2 id="description">Description:</h2>
<p>Reads the container name from the docker-compose-template.yml file.</p>
<h2 id="parameters">Parameters:</h2>
<p>Job ID : str
Unique JobID that consists of an uuid and the datetime</p>
<p>instanceName : str
The instance name of the application that is used </p>
<h2 id="raises">Raises:</h2>
<h2 id="returns">Returns:</h2>
<p>ContainerNames: list
The names of the containers, that are runninng the application
mainContainer: str
The name of the main container</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def readContainernames(self, jobID, instanceName):
    &#39;&#39;&#39;
    Description:
    -----------
    Reads the container name from the docker-compose-template.yml file.

    Parameters:
    ----------
    Job ID : str
        Unique JobID that consists of an uuid and the datetime

    instanceName : str
        The instance name of the application that is used 
    
    Raises:
    -------

    Returns:
    -------
    ContainerNames: list
        The names of the containers, that are runninng the application
    mainContainer: str
        The name of the main container
    &#39;&#39;&#39;

    app_logger, bibbox_logger, docker_logger, app_errorlogger = AppController.setUpLog(self, jobID, instanceName)
    app_logger.info( &#39;Read Containernames&#39;)
    rootdir = dirname(dirname(abspath(__file__)))
    appPath = rootdir + &#39;/application-instance&#39;
    if path.exists(appPath) == False:
        raise Exception(&#39;The folder &#34;/application-instance&#34; does not exist!&#39;)
    composefile = open(appPath + &#39;/&#39; + instanceName +&#39;/repo/docker-compose-template.yml&#39;, &#39;r&#39;).read()
    try:
        data = yaml.load(composefile, Loader=yaml.FullLoader)
    except Exception:
        app_errorlogger.exception(&#39;Fatal error in loading compose file: &#39;, exc_info=True)
    ContainerNames = []
    try:
        for k, v in data[&#34;services&#34;].items():
            if &#39;container_name&#39; in v:
                mainContainer = v.get(&#39;container_name&#39;)
                mainContainer = mainContainer.replace(&#39;§§INSTANCE&#39;, instanceName)
                try:
                    mainContainer = mainContainer.replace(&#39;-db&#39;, &#39;&#39;)
                except:
                    pass
            if &#39;container_name&#39; in v:
                ContainerName = v.get(&#39;container_name&#39;)
                ContainerName = ContainerName.replace(&#39;§§INSTANCE&#39;, instanceName)
                ContainerNames.append(ContainerName)
    except Exception:
        app_errorlogger.exception(&#39;Fatal error in reading compose file: &#39;, exc_info=True)

    return ContainerNames, mainContainer</code></pre>
</details>
</dd>
<dt id="helperFunctions.AppController.readVersion"><code class="name flex">
<span>def <span class="ident">readVersion</span></span>(<span>self, jobID, appName)</span>
</code></dt>
<dd>
<div class="desc"><h2 id="description">Description:</h2>
<p>Lists the available Apps.</p>
<h2 id="parameters">Parameters:</h2>
<h2 id="raises">Raises:</h2>
<h2 id="returns">Returns:</h2>
<p>appslist: json object
The list of all available apps as json object</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def readVersion(self, jobID, appName):
    &#39;&#39;&#39;
    Description:
    -----------
    Lists the available Apps.

    Parameters:
    ----------

    Raises:
    -------

    Returns:
    -------
    appslist: json object
        The list of all available apps as json object
    &#39;&#39;&#39;

    try:
        url = &#39;https://raw.githubusercontent.com/bibbox/application-store/master/eB3Kit.json&#39;
        download = requests.get(url).content
    except Exception:
        raise Exception(&#39;Something went wrong during connecting to the GitHub repository. Please Check your internet connection!&#39;)
    try:
        params = simplejson.loads(download)
    except Exception:
        #app_errorlogger.exception(&#39;Error while loading eB3Kit.json file: &#39;, exc_info=True)
        raise Exception(&#39;Error while loading eB3Kit.json file&#39;)
    versionList=[]
    try:
        for i, values in enumerate(params):
            variable = values[&#39;group_members&#39;]
            for i, var in enumerate(variable):
                if var[&#39;app_name&#39;] == appName:
                    versions = var[&#39;versions&#39;]
                    for version in versions:
                        versionList.append(version[&#39;docker_version&#39;])
                if var[&#39;app_display_name&#39;] == appName:
                    versions = var[&#39;versions&#39;]
                    for version in versions:
                        versionList.append(version[&#39;docker_version&#39;])
    except:
        raise Exception(&#39;The wanted app does not exist. Please check the list of available apps!&#39;)                

    return versionList</code></pre>
</details>
</dd>
<dt id="helperFunctions.AppController.remove"><code class="name flex">
<span>def <span class="ident">remove</span></span>(<span>self, jobID, instanceName)</span>
</code></dt>
<dd>
<div class="desc"><h2 id="description">Description:</h2>
<p>Executes the doker-compose down command to stop and remove the application</p>
<h2 id="parameters">Parameters:</h2>
<p>Job ID : str
Unique JobID that consists of an uuid and the datetime</p>
<p>instanceName : str
The instance name of the application that is used </p>
<h2 id="raises">Raises:</h2>
<h2 id="returns">Returns:</h2></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def remove(self, jobID, instanceName):
    &#39;&#39;&#39;
    Description:
    -----------
    Executes the doker-compose down command to stop and remove the application

    Parameters:
    ----------
    Job ID : str
        Unique JobID that consists of an uuid and the datetime

    instanceName : str
        The instance name of the application that is used 
    
    Raises:
    -------

    Returns:
    -------
    &#39;&#39;&#39;

    app_logger, bibbox_logger, docker_logger, app_errorlogger = AppController.setUpLog(self, jobID, instanceName)
    app_logger.info( &#39;Removing App:&#39; + instanceName)
    rootdir = dirname(dirname(abspath(__file__)))
    appPath = rootdir + &#39;/application-instance/&#39; + instanceName + &#39;/repo/&#39;
    if path.exists(appPath) == False:
        app_errorlogger.error( &#39;The folder of the app repository does not exist!&#39;)
    process = subprocess.Popen([&#39;docker-compose&#39;, &#39;-f&#39;, appPath + &#39;/docker-compose-template.yml&#39;, &#39;down&#39;], stdout=subprocess.PIPE, stderr=subprocess.STDOUT, encoding=&#34;utf8&#34;)
    output, error = process.communicate()
    if output:
        docker_logger.error( str(output))
    process = subprocess.Popen([&#39;sudo&#39;, &#39;chmod&#39; ,&#39;-f&#39;, &#39;-R&#39;, &#39;777&#39;, rootdir + &#39;/application-instance/&#39; + instanceName], stdout=subprocess.PIPE, stderr=subprocess.STDOUT, encoding=&#34;utf8&#34;)
    output, error = process.communicate()
    if output:
        bibbox_logger.error( str(output))
    process = subprocess.Popen([&#39;rm&#39; , &#39;-f&#39;, &#39;-R&#39;, rootdir + &#39;/application-instance/&#39; + instanceName], stdout=subprocess.PIPE, stderr=subprocess.STDOUT, encoding=&#34;utf8&#34;)
    output, error = process.communicate()
    if output:
        bibbox_logger.error( str(output))
    process = subprocess.Popen([&#39;rm&#39; , &#39;-f&#39;, rootdir + &#39;/sys-proxy/proxyconfig/sites/&#39; + instanceName + &#39;.conf&#39;], stdout=subprocess.PIPE, stderr=subprocess.STDOUT, encoding=&#34;utf8&#34;)
    output, error = process.communicate()
    if output:
        bibbox_logger.error( str(output))</code></pre>
</details>
</dd>
<dt id="helperFunctions.AppController.setInfo"><code class="name flex">
<span>def <span class="ident">setInfo</span></span>(<span>self, jobID, instanceName, appName, version)</span>
</code></dt>
<dd>
<div class="desc"><h2 id="description">Description:</h2>
<p>Creates a file named INFO where install information is stored.</p>
<h2 id="parameters">Parameters:</h2>
<p>Job ID : str
Unique JobID that consists of an uuid and the datetime</p>
<p>instanceName : str
The instance name of the application that is used </p>
<p>appName : str
The (github) name of the application that is used </p>
<p>version : str
The wanted version of the application that is used </p>
<h2 id="raises">Raises:</h2>
<h2 id="returns">Returns:</h2></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def setInfo(self, jobID, instanceName,appName,version):
    &#39;&#39;&#39;
    Description:
    -----------
    Creates a file named INFO where install information is stored.

    Parameters:
    ----------
    Job ID : str
        Unique JobID that consists of an uuid and the datetime

    instanceName : str
        The instance name of the application that is used 

    appName : str
        The (github) name of the application that is used 

    version : str
        The wanted version of the application that is used 
    
    Raises:
    -------

    Returns:
    -------
    
    &#39;&#39;&#39;

    app_logger, bibbox_logger, docker_logger, app_errorlogger = AppController.setUpLog(self, jobID, instanceName)
    app_logger.info( &#39;Set install info&#39;)
    rootdir = dirname(dirname(abspath(__file__)))
    appPath = rootdir + &#39;/application-instance&#39;
    if path.exists(appPath) == False:
        raise Exception(&#39;The folder &#34;/application-instance&#34; does not exist!&#39;)

    data = {}
    data[&#39;instanceName&#39;] = instanceName
    data[&#39;appName&#39;] = appName
    data[&#39;version&#39;] = version
    data[&#39;jobID&#39;] = jobID
    try:
        with open(appPath + &#39;/&#39; + instanceName + &#39;/info.json&#39;, &#39;w+&#39;) as outfile:
            json.dump(data, outfile)
    except Exception:
            app_errorlogger.exception(&#39;Could not open file &#34;info.json&#34; in application folder! &#39;, exc_info=True)
            raise Exception(&#39;Could not open file &#34;info.json&#34; in application folder! &#39;)
    if path.exists(appPath + &#39;/&#39; + instanceName + &#39;/info.json&#39;) == False:
        app_errorlogger.exception(&#39;Something went wrong during writing install information to info.json file of app: &#39; + instanceName, exc_info=True)
        raise Exception(&#39;Fatal error in during writing install information to info.json file of app: &#39; + instanceName)</code></pre>
</details>
</dd>
<dt id="helperFunctions.AppController.setParams"><code class="name flex">
<span>def <span class="ident">setParams</span></span>(<span>self, paramList)</span>
</code></dt>
<dd>
<div class="desc"><h2 id="description">Description:</h2>
<p>Reads the user parameters of an app.</p>
<h2 id="parameters">Parameters:</h2>
<p>paramList: array
List of all userparameters</p>
<h2 id="raises">Raises:</h2>
<h2 id="returns">Returns:</h2></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def setParams(self, paramList):
    &#39;&#39;&#39;
    Description:
    -----------
    Reads the user parameters of an app.

    Parameters:
    ----------
    paramList: array
        List of all userparameters

    Raises:
    -------

    Returns:
    -------
    &#39;&#39;&#39;
    for key in paramList:
        paramList[key] = &#39;seeddms&#39;

    return paramList</code></pre>
</details>
</dd>
<dt id="helperFunctions.AppController.setProxyFiles"><code class="name flex">
<span>def <span class="ident">setProxyFiles</span></span>(<span>self, jobID, instanceName, containerName)</span>
</code></dt>
<dd>
<div class="desc"><h2 id="description">Description:</h2>
<p>Creates a proxy config file for the nginx web server to use the app container as sub url.</p>
<h2 id="parameters">Parameters:</h2>
<p>Job ID : str
Unique JobID that consists of an uuid and the datetime</p>
<p>instanceName : str
The instance name of the application that is used </p>
<p>containerName : str
The name of the container, that is runninng the application </p>
<h2 id="raises">Raises:</h2>
<h2 id="returns">Returns:</h2></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def setProxyFiles(self, jobID, instanceName, containerName):
    &#39;&#39;&#39;
    Description:
    -----------
    Creates a proxy config file for the nginx web server to use the app container as sub url.

    Parameters:
    ----------
    Job ID : str
        Unique JobID that consists of an uuid and the datetime

    instanceName : str
        The instance name of the application that is used 

    containerName : str
        The name of the container, that is runninng the application 

    
    Raises:
    -------

    Returns:
    -------
    
    &#39;&#39;&#39;

    app_logger, bibbox_logger, docker_logger, app_errorlogger = AppController.setUpLog(self, jobID, instanceName)
    app_logger.info( &#39;Set proxy files&#39;)
    rootdir = dirname(dirname(abspath(__file__)))
    proxyPath = rootdir + &#39;/sys-proxy/&#39;
    if path.exists(proxyPath) == False:
        app_errorlogger.error(&#39;The folder &#34;sys-proxy&#34; does not exist!&#39;)
    if path.exists(proxyPath + &#39;proxyconfig/sites/&#39;) == False:
        process = subprocess.Popen([&#39;mkdir&#39;, proxyPath + &#39;proxyconfig/sites/&#39;])
        output, error = process.communicate()
        if output:
            bibbox_logger.debug( str(output))
    name = instanceName + &#39;.conf&#39;
    
    try:
        with open(proxyPath + &#39;template.conf&#39;) as template:
            file_content = template.read()
            file_content = file_content.replace(&#34;§§INSTANCEID&#34;, instanceName)
            file_content = file_content.replace(&#34;§§CONTAINERNAME&#34;, containerName)
            template = open( proxyPath + &#39;proxyconfig/sites/&#39; + name, &#39;w+&#39;)
            template.write(file_content)
            template.close()
    except Exception:
        app_errorlogger.exception(&#39;Fatal error in writing to proxy template file: &#39;, exc_info=True)
    if path.exists(proxyPath + &#39;proxyconfig/sites/&#39; + name) == False:
        app_errorlogger.exception(&#39;Something went wrong during writing the proxy file for app: &#39; + instanceName, exc_info=True)
        raise Exception(&#39;Fatal error in during writing the proxy file for app: &#39; + instanceName)</code></pre>
</details>
</dd>
<dt id="helperFunctions.AppController.setStatus"><code class="name flex">
<span>def <span class="ident">setStatus</span></span>(<span>self, jobID, status, instanceName)</span>
</code></dt>
<dd>
<div class="desc"><h2 id="description">Description:</h2>
<p>Sets the current ststus of an app and writes it to a file calles STATUS.</p>
<h2 id="parameters">Parameters:</h2>
<p>Job ID : str
Unique JobID that consists of an uuid and the datetime</p>
<p>status: str
The wanted ststus that gets written to the STATUS file</p>
<p>instanceName : str
The instance name of the application that is used </p>
<h2 id="raises">Raises:</h2>
<h2 id="returns">Returns:</h2></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def setStatus(self, jobID, status, instanceName):
    &#39;&#39;&#39;
    Description:
    -----------
    Sets the current ststus of an app and writes it to a file calles STATUS.

    Parameters:
    ----------
    Job ID : str
        Unique JobID that consists of an uuid and the datetime

    status: str
        The wanted ststus that gets written to the STATUS file

    instanceName : str
        The instance name of the application that is used 
    
    Raises:
    -------
    

    Returns:
    -------
    
    &#39;&#39;&#39;

    app_logger, bibbox_logger, docker_logger, app_errorlogger = AppController.setUpLog(self, jobID, instanceName)
    app_logger.info(&#39;Set status to &#39; + status )
    rootdir = dirname(dirname(abspath(__file__)))
    appPath = rootdir + &#39;/application-instance&#39;
    if path.exists(appPath) == False:
        app_errorlogger.error( &#39; - The folder &#34;/application-instance&#34; does not exist!&#39;)
    process = subprocess.Popen([&#39;touch&#39; , appPath + &#39;/&#39; + instanceName + &#39;/STATUS&#39;], stdout=subprocess.PIPE, stderr=subprocess.STDOUT)
    output, error = process.communicate()
    if output:
        app_errorlogger.error( str(output))
    try:
        text_file = open(appPath + &#39;/&#39; + instanceName + &#39;/STATUS&#39;, &#34;w&#34;)
        text_file.write(status)
        text_file.close()
    except Exception:
        app_errorlogger.exception(&#39;Fatal error in writing to STATUS file: &#39;, exc_info=True)
        raise Exception(&#39;Fatal error in writing to STATUS file: &#39;)
    if path.exists(appPath + &#39;/&#39; + instanceName + &#39;/STATUS&#39;) == False:
        app_errorlogger.exception(&#39;Something went wrong during writing to STATUS file: &#39;, exc_info=True)
        raise Exception(&#39;Fatal error in writing to STATUS file: &#39;)</code></pre>
</details>
</dd>
<dt id="helperFunctions.AppController.setUpLog"><code class="name flex">
<span>def <span class="ident">setUpLog</span></span>(<span>self, jobID, instanceName, systemonly=False)</span>
</code></dt>
<dd>
<div class="desc"><h2 id="description">Description:</h2>
<p>Sets up initial log settings, such as format, file name etc.</p>
<h2 id="parameters">Parameters:</h2>
<p>Job ID : str
Unique JobID that consists of an uuid and the datetime</p>
<p>instanceName : str
The instance name of the application that is used </p>
<h2 id="raises">Raises:</h2>
<h2 id="returns">Returns:</h2></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def setUpLog(self, jobID, instanceName, systemonly = False):
    &#39;&#39;&#39;
    Description:
    -----------
    Sets up initial log settings, such as format, file name etc.

    Parameters:
    ----------
    Job ID : str
        Unique JobID that consists of an uuid and the datetime

    instanceName : str
        The instance name of the application that is used 
    
    Raises:
    -------
    

    Returns:
    -------
    
    &#39;&#39;&#39;
    rootdir = dirname(dirname(abspath(__file__)))
    if systemonly == False:
        appPath = rootdir + &#39;/application-instance&#39;
        if path.exists(appPath) == False:
            raise Exception( &#39; - The folder &#34;/application-instance/&#34; does not exist!&#39;)
        logpath = appPath + &#39;/&#39; + instanceName + &#39;/log/&#39;
        if path.exists(logpath) == False:
            raise Exception( &#39; - The folder &#34;/application-instance/&#39; + instanceName + &#39;/log/&#34; does not exist!&#39;)
        app_logger = AppController.setup_logger(self, jobID, instanceName + &#39;-app.log&#39;, logpath + &#39;debug.log&#39;, level=logging.DEBUG)
        app_errorlogger = AppController.setup_logger(self, jobID, instanceName + &#39;-apperror.log&#39;, logpath + &#39;error.log&#39;, level=logging.DEBUG)
        docker_logger = AppController.setup_logger(self, jobID, instanceName + &#39;-docker.log&#39;, logpath + &#39;docker.log&#39;, level=logging.DEBUG)
        bibbox_logger = AppController.setup_logger(self, jobID, instanceName + &#39;-bibbox.log&#39;, rootdir + &#39;/log/system.log&#39;, level=logging.DEBUG)
        
        if path.exists(logpath + &#39;debug.log&#39;) == False:
            raise Exception(&#39;Error while creating logfile &#34;debug.log&#34; in folder &#39; + logpath + &#39;.&#39;)
        if path.exists(logpath + &#39;error.log&#39;) == False:
            raise Exception(&#39;Error while creating logfile &#34;error.log&#34; in folder &#39; + logpath + &#39;.&#39;)
        if path.exists(logpath + &#39;docker.log&#39;) == False:
            raise Exception(&#39;Error while creating logfile &#34;docker.log&#34; in folder &#39; + logpath + &#39;.&#39;)
        if path.exists(rootdir + &#39;/log/system.log&#39;) == False:
            raise Exception(&#39;Error while creating logfile &#34;system.log&#34; in folder &#39; + logpath + &#39;.&#39;)
        
        return app_logger, bibbox_logger, docker_logger, app_errorlogger
    else:
        bibbox_logger = AppController.setup_logger(self, jobID, instanceName + &#39;bibbox&#39;, rootdir + &#39;/log/system.log&#39;, level=logging.DEBUG)
        if path.exists(rootdir + &#39;/log/system.log&#39;) == False:
            raise Exception(&#39;Error while creating logfile &#34;system.log&#34;&#39;)
        
        return bibbox_logger</code></pre>
</details>
</dd>
<dt id="helperFunctions.AppController.setup_logger"><code class="name flex">
<span>def <span class="ident">setup_logger</span></span>(<span>self, jobID, loggerName, log_file, level=10)</span>
</code></dt>
<dd>
<div class="desc"><h2 id="description">Description:</h2>
<p>Sets up logger.</p>
<h2 id="parameters">Parameters:</h2>
<p>Job ID : str
Unique JobID that consists of an uuid and the datetime</p>
<p>loggerName : str
Name of the logger </p>
<p>logfile : str
Path like object that defines the logfile destination and the logfile's name</p>
<h2 id="raises">Raises:</h2>
<h2 id="returns">Returns:</h2></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def setup_logger(self, jobID, loggerName, log_file, level=logging.DEBUG):
    &#39;&#39;&#39;
    Description:
    -----------
    Sets up logger.

    Parameters:
    ----------
    Job ID : str
        Unique JobID that consists of an uuid and the datetime

    loggerName : str
        Name of the logger 

    logfile : str
        Path like object that defines the logfile destination and the logfile&#39;s name
    
    Raises:
    -------
    

    Returns:
    -------
    
    &#39;&#39;&#39;
    
    formatter = logging.Formatter(&#39;%(asctime)s - %(levelname)s - %(name)s - %(message)s&#39;)
    logformatter = logging.Formatter(jobID + &#39;%(asctime)s - %(levelname)s - %(name)s - %(message)s&#39;)
    logger = logging.getLogger(loggerName)
    if logger.handlers[:] == []:
        handler = logging.handlers.RotatingFileHandler(log_file, maxBytes=20000000, backupCount = 10)
        handler.setFormatter(logformatter)
        stream = logging.StreamHandler()
        stream.setFormatter(formatter)
        logger.addHandler(stream)
        logger.addHandler(handler)
    logger.setLevel(level)

    return logger</code></pre>
</details>
</dd>
<dt id="helperFunctions.AppController.start"><code class="name flex">
<span>def <span class="ident">start</span></span>(<span>self, jobID, instanceName)</span>
</code></dt>
<dd>
<div class="desc"><h2 id="description">Description:</h2>
<p>Executes the doker-compose start command to start the application</p>
<h2 id="parameters">Parameters:</h2>
<p>Job ID : str
Unique JobID that consists of an uuid and the datetime</p>
<p>instanceName : str
The instance name of the application that is used </p>
<h2 id="raises">Raises:</h2>
<h2 id="returns">Returns:</h2></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def start(self, jobID, instanceName):
    &#39;&#39;&#39;
    Description:
    -----------
    Executes the doker-compose start command to start the application

    Parameters:
    ----------
    Job ID : str
        Unique JobID that consists of an uuid and the datetime

    instanceName : str
        The instance name of the application that is used 
    
    Raises:
    -------

    Returns:
    -------
    &#39;&#39;&#39;

    app_logger, bibbox_logger, docker_logger, app_errorlogger = AppController.setUpLog(self, jobID, instanceName)
    app_logger.info( &#39;Starting App:&#39; + instanceName)
    rootdir = dirname(dirname(abspath(__file__)))
    appPath = rootdir + &#39;/application-instance/&#39; + instanceName + &#39;/repo/&#39;
    if path.exists(appPath) == False:
        app_errorlogger.error( &#39; The folder of the app repository does not exist!&#39;)
    process = subprocess.Popen([&#39;docker-compose&#39;, &#39;-f&#39;, appPath + &#39;/docker-compose-template.yml&#39;, &#39;start&#39;], stdout=subprocess.PIPE, stderr=subprocess.STDOUT, encoding=&#34;utf8&#34;)
    output, error = process.communicate()
    if output:
        docker_logger.error( str(output).rstrip())</code></pre>
</details>
</dd>
<dt id="helperFunctions.AppController.startNginx"><code class="name flex">
<span>def <span class="ident">startNginx</span></span>(<span>self, JobID)</span>
</code></dt>
<dd>
<div class="desc"><h2 id="description">Description:</h2>
<p>Starts the nginx proxy of the bibbox system.</p>
<h2 id="parameters">Parameters:</h2>
<p>jobID : str
Unique JobID that consists of an uuid and the datetime</p>
<h2 id="raises">Raises:</h2>
<h2 id="returns">Returns:</h2></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def startNginx(self, JobID):
    &#39;&#39;&#39;
    Description:
    -----------
    Starts the nginx proxy of the bibbox system.

    Parameters:
    ----------

    jobID : str
        Unique JobID that consists of an uuid and the datetime

    
    Raises:
    -------

    Returns:
    -------
    
    &#39;&#39;&#39;
    bibbox_logger = AppController.setUpLog(self, JobID, &#39;system&#39;, systemonly=True)
    bibbox_logger.info(&#39;Starting nginx container&#39;)
    
    process = subprocess.Popen([&#39;docker-compose&#39;,&#39;-f&#39;, &#39;/opt/bibbox/sys-bibbox/docker-compose.yml&#39;, &#39;up&#39;, &#39;-d&#39;], stdout=subprocess.PIPE, stderr=subprocess.STDOUT)
    output, error = process.communicate()
    if output:
        output = output.decode(&#39;utf8&#39;)
        output = output.strip()
        bibbox_logger.error(output)</code></pre>
</details>
</dd>
<dt id="helperFunctions.AppController.status"><code class="name flex">
<span>def <span class="ident">status</span></span>(<span>self, jobID, instanceName)</span>
</code></dt>
<dd>
<div class="desc"><h2 id="description">Description:</h2>
<p>Reads the file STATUS to get the currend state of an application</p>
<h2 id="parameters">Parameters:</h2>
<p>Job ID : str
Unique JobID that consists of an uuid and the datetime</p>
<p>instanceName : str
The instance name of the application that is used </p>
<h2 id="raises">Raises:</h2>
<h2 id="returns">Returns:</h2>
<p>status: str
The current status of an application</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def status(self, jobID, instanceName):
    &#39;&#39;&#39;
    Description:
    -----------
    Reads the file STATUS to get the currend state of an application

    Parameters:
    ----------
    Job ID : str
        Unique JobID that consists of an uuid and the datetime

    instanceName : str
        The instance name of the application that is used 
    
    Raises:
    -------

    Returns:
    -------
    status: str
        The current status of an application
    &#39;&#39;&#39;

    app_logger, bibbox_logger, docker_logger, app_errorlogger = AppController.setUpLog(self, jobID, instanceName)
    app_logger.info( &#39;Reading Status of App: &#39; + instanceName)
    rootdir = dirname(dirname(abspath(__file__)))
    appPath = rootdir + &#39;/application-instance/&#39; + instanceName + &#39;/&#39;
    if path.exists(appPath) == False:
        app_errorlogger.error( &#39; The folder of the app repository does not exist!&#39;)
    try:
        with open(appPath + &#39;STATUS&#39;) as statusfile:
            file_content = statusfile.read()
    except Exception:
        app_errorlogger.exception(&#39;Could not open STATUS file: &#39;, exc_info=True)
    return file_content</code></pre>
</details>
</dd>
<dt id="helperFunctions.AppController.stop"><code class="name flex">
<span>def <span class="ident">stop</span></span>(<span>self, jobID, instanceName)</span>
</code></dt>
<dd>
<div class="desc"><h2 id="description">Description:</h2>
<p>Executes the doker-compose stop command to stop the application</p>
<h2 id="parameters">Parameters:</h2>
<p>Job ID : str
Unique JobID that consists of an uuid and the datetime</p>
<p>instanceName : str
The instance name of the application that is used </p>
<h2 id="raises">Raises:</h2>
<h2 id="returns">Returns:</h2></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def stop(self, jobID, instanceName):
    &#39;&#39;&#39;
    Description:
    -----------
    Executes the doker-compose stop command to stop the application

    Parameters:
    ----------
    Job ID : str
        Unique JobID that consists of an uuid and the datetime

    instanceName : str
        The instance name of the application that is used 
    
    Raises:
    -------

    Returns:
    -------
    &#39;&#39;&#39;

    app_logger, bibbox_logger, docker_logger, app_errorlogger = AppController.setUpLog(self, jobID, instanceName)
    app_logger.info( &#39;Stopping App:&#39; + instanceName)
    rootdir = dirname(dirname(abspath(__file__)))
    appPath = rootdir + &#39;/application-instance/&#39; + instanceName + &#39;/repo/&#39;
    if path.exists(appPath) == False:
        app_logger.error(&#39;The folder of the app repository does not exist!&#39;)
    process = subprocess.Popen([&#39;docker-compose&#39;, &#39;-f&#39;, appPath + &#39;/docker-compose-template.yml&#39;, &#39;stop&#39;], stdout=subprocess.PIPE, stderr=subprocess.STDOUT, encoding=&#34;utf8&#34;)
    output, error = process.communicate()
    if output:
        docker_logger.error( str(output).rstrip())</code></pre>
</details>
</dd>
<dt id="helperFunctions.AppController.stopNginx"><code class="name flex">
<span>def <span class="ident">stopNginx</span></span>(<span>self, JobID)</span>
</code></dt>
<dd>
<div class="desc"><h2 id="description">Description:</h2>
<p>Stops the nginx proxy of the bibbox system.</p>
<h2 id="parameters">Parameters:</h2>
<p>jobID : str
Unique JobID that consists of an uuid and the datetime</p>
<h2 id="raises">Raises:</h2>
<h2 id="returns">Returns:</h2></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def stopNginx(self, JobID):
    &#39;&#39;&#39;
    Description:
    -----------
    Stops the nginx proxy of the bibbox system.

    Parameters:
    ----------

    jobID : str
        Unique JobID that consists of an uuid and the datetime

    
    Raises:
    -------

    Returns:
    -------
    
    &#39;&#39;&#39;
    bibbox_logger = AppController.setUpLog(self, JobID, &#39;system&#39;, systemonly=True)
    bibbox_logger.info(&#39;Stopping nginx container&#39;)
    
    process = subprocess.Popen([&#39;docker-compose&#39;,&#39;-f&#39;, &#39;/opt/bibbox/sys-bibbox/docker-compose.yml&#39;, &#39;down&#39;], stdout=subprocess.PIPE, stderr=subprocess.STDOUT)
    output, error = process.communicate()
    if output:
        output = output.decode(&#39;utf8&#39;)
        output = output.strip()
        bibbox_logger.error(output)</code></pre>
</details>
</dd>
<dt id="helperFunctions.AppController.unlock"><code class="name flex">
<span>def <span class="ident">unlock</span></span>(<span>self, jobID, instanceName, end=False)</span>
</code></dt>
<dd>
<div class="desc"><h2 id="description">Description:</h2>
<p>Deletes a file named LOCK to lock an app, so that one is able to perform other operations
on an app after the current operation is finished.</p>
<h2 id="parameters">Parameters:</h2>
<p>Job ID : str
Unique JobID that consists of an uuid and the datetime</p>
<p>instanceName : str
The instance name of the application that is used </p>
<h2 id="raises">Raises:</h2>
<h2 id="returns">Returns:</h2></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def unlock(self, jobID, instanceName, end = False):
    &#39;&#39;&#39;
    Description:
    -----------
    Deletes a file named LOCK to lock an app, so that one is able to perform other operations
    on an app after the current operation is finished.

    Parameters:
    ----------
    Job ID : str
        Unique JobID that consists of an uuid and the datetime

    instanceName : str
        The instance name of the application that is used 
    
    Raises:
    -------

    Returns:
    -------
    
    &#39;&#39;&#39;
    rootdir = dirname(dirname(abspath(__file__)))
    appPath = rootdir + &#39;/application-instance&#39;
    if path.exists(appPath) == False:
        app_errorlogger.error(&#39; - The folder &#34;/application-instance&#34; does not exist!&#39;)
    process = subprocess.Popen([&#39;rm&#39; , appPath + &#39;/&#39; + instanceName + &#39;/LOCK&#39;], stdout=subprocess.PIPE, stderr=subprocess.STDOUT)
    output, error = process.communicate()
    if end == False:
        if output:
            app_errorlogger.error(str(output) )
    if path.exists(appPath + &#39;/&#39; + instanceName + &#39;/LOCK&#39;) == True:
        app_errorlogger.exception(&#39;Something went wrong during deleting LOCK file: &#39;, exc_info=True)
        raise Exception(&#39;Fatal error in deleting LOCK file: &#39;)
    app_logger, bibbox_logger, docker_logger, app_errorlogger = AppController.setUpLog(self, jobID, instanceName)
    app_logger.debug(&#39;App &#39; + instanceName + &#39; unlocked&#39;)</code></pre>
</details>
</dd>
<dt id="helperFunctions.AppController.writeCLICompose"><code class="name flex">
<span>def <span class="ident">writeCLICompose</span></span>(<span>self, jobID, paramList, keyList, instanceName)</span>
</code></dt>
<dd>
<div class="desc"><h2 id="description">Description:</h2>
<p>Changes the instance name of the docker-compose-template.yml file.</p>
<h2 id="parameters">Parameters:</h2>
<p>Job ID : str
Unique JobID that consists of an uuid and the datetime</p>
<p>paramList: array
list of environment variables that are defined in the .env file in the repository of the application</p>
<p>instanceName : str
The instance name of the application that is used </p>
<h2 id="raises">Raises:</h2>
<h2 id="returns">Returns:</h2></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def writeCLICompose(self, jobID, paramList, keyList, instanceName):
    &#39;&#39;&#39;
    Description:
    -----------
    Changes the instance name of the docker-compose-template.yml file.

    Parameters:
    ----------
    Job ID : str
        Unique JobID that consists of an uuid and the datetime

    paramList: array
        list of environment variables that are defined in the .env file in the repository of the application

    instanceName : str
        The instance name of the application that is used 
    
    Raises:
    -------

    Returns:
    -------
    &#39;&#39;&#39;

    app_logger, bibbox_logger, docker_logger, app_errorlogger = AppController.setUpLog(self, jobID, instanceName)
    app_logger.info(&#39;Write parameters to compose file&#39;)
    rootdir = dirname(dirname(abspath(__file__)))
    appPath = rootdir + &#39;/application-instance/&#39; + instanceName + &#39;/repo/&#39;
    if path.exists(appPath) == False:
        raise Exception(&#39;The folder &#34;/application-instance&#34; does not exist!&#39;)
    try:
        compose = open(appPath + &#39;/docker-compose-template.yml&#39;, &#39;r&#39;).read()
    except Exception:
        app_errorlogger.exception(&#39;Fatal error in reading compose file: &#39;, exc_info=True)
    paramList = re.sub(&#34;[^\w]&#34;, &#34; &#34;, paramList).split()
    
    keyList = re.sub(&#34;[^\w]&#34;, &#34; &#34;, keyList).split()
    
    
    for i, key in enumerate(keyList):
        if key != &#39;&#39;:
            compose = compose.replace(&#39;§§&#39; + key, paramList[i])
    
    
    compose = compose.replace(&#39;§§INSTANCE&#39;, instanceName)
    target = open(appPath + &#39;/docker-compose-template.yml&#39;, &#39;w&#39;)
    target.write(compose)
    target.close()</code></pre>
</details>
</dd>
<dt id="helperFunctions.AppController.writeCompose"><code class="name flex">
<span>def <span class="ident">writeCompose</span></span>(<span>self, jobID, paramList, instanceName)</span>
</code></dt>
<dd>
<div class="desc"><h2 id="description">Description:</h2>
<p>Changes the instance name of the docker-compose-template.yml file.</p>
<h2 id="parameters">Parameters:</h2>
<p>Job ID : str
Unique JobID that consists of an uuid and the datetime</p>
<p>paramList: array
list of environment variables that are defined in the .env file in the repository of the application</p>
<p>instanceName : str
The instance name of the application that is used </p>
<h2 id="raises">Raises:</h2>
<h2 id="returns">Returns:</h2></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def writeCompose(self, jobID, paramList, instanceName):
    &#39;&#39;&#39;
    Description:
    -----------
    Changes the instance name of the docker-compose-template.yml file.

    Parameters:
    ----------
    Job ID : str
        Unique JobID that consists of an uuid and the datetime

    paramList: array
        list of environment variables that are defined in the .env file in the repository of the application

    instanceName : str
        The instance name of the application that is used 
    
    Raises:
    -------

    Returns:
    -------
    &#39;&#39;&#39;

    app_logger, bibbox_logger, docker_logger, app_errorlogger = AppController.setUpLog(self, jobID, instanceName)
    app_logger.info(&#39;Write parameters to compose file&#39;)
    rootdir = dirname(dirname(abspath(__file__)))
    appPath = rootdir + &#39;/application-instance/&#39; + instanceName + &#39;/repo/&#39;
    if path.exists(appPath) == False:
        raise Exception(&#39;The folder &#34;/application-instance&#34; does not exist!&#39;)
    try:
        compose = open(appPath + &#39;/docker-compose-template.yml&#39;, &#39;r&#39;).read()
    except Exception:
        app_errorlogger.exception(&#39;Fatal error in reading compose file: &#39;, exc_info=True)

    try:
        for i, key in enumerate(paramList):
            compose = compose.replace(&#39;§§&#39; + key, paramList[key])
    except Exception:
        app_errorlogger.exception(&#39;Fatal error in writing to compose file: &#39;, exc_info=True)
    try:
        compose = compose.replace(&#39;§§INSTANCE&#39;, instanceName)
        target = open(appPath + &#39;/docker-compose-template.yml&#39;, &#39;w&#39;)
        target.write(compose)
        target.close()
    except Exception:
        app_errorlogger.exception(&#39;Fatal error in writing to compose file: &#39;, exc_info=True)</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="helperFunctions.AppController" href="#helperFunctions.AppController">AppController</a></code></h4>
<ul class="two-column">
<li><code><a title="helperFunctions.AppController.changeCompose" href="#helperFunctions.AppController.changeCompose">changeCompose</a></code></li>
<li><code><a title="helperFunctions.AppController.changeInfo" href="#helperFunctions.AppController.changeInfo">changeInfo</a></code></li>
<li><code><a title="helperFunctions.AppController.changeSettings" href="#helperFunctions.AppController.changeSettings">changeSettings</a></code></li>
<li><code><a title="helperFunctions.AppController.checkDockerState" href="#helperFunctions.AppController.checkDockerState">checkDockerState</a></code></li>
<li><code><a title="helperFunctions.AppController.checkExists" href="#helperFunctions.AppController.checkExists">checkExists</a></code></li>
<li><code><a title="helperFunctions.AppController.checkInput" href="#helperFunctions.AppController.checkInput">checkInput</a></code></li>
<li><code><a title="helperFunctions.AppController.checkInstall" href="#helperFunctions.AppController.checkInstall">checkInstall</a></code></li>
<li><code><a title="helperFunctions.AppController.checkProxy" href="#helperFunctions.AppController.checkProxy">checkProxy</a></code></li>
<li><code><a title="helperFunctions.AppController.checkStatus" href="#helperFunctions.AppController.checkStatus">checkStatus</a></code></li>
<li><code><a title="helperFunctions.AppController.checkSystem" href="#helperFunctions.AppController.checkSystem">checkSystem</a></code></li>
<li><code><a title="helperFunctions.AppController.composeUp" href="#helperFunctions.AppController.composeUp">composeUp</a></code></li>
<li><code><a title="helperFunctions.AppController.copy" href="#helperFunctions.AppController.copy">copy</a></code></li>
<li><code><a title="helperFunctions.AppController.createFolder" href="#helperFunctions.AppController.createFolder">createFolder</a></code></li>
<li><code><a title="helperFunctions.AppController.createJobID" href="#helperFunctions.AppController.createJobID">createJobID</a></code></li>
<li><code><a title="helperFunctions.AppController.downloadApp" href="#helperFunctions.AppController.downloadApp">downloadApp</a></code></li>
<li><code><a title="helperFunctions.AppController.getAppName" href="#helperFunctions.AppController.getAppName">getAppName</a></code></li>
<li><code><a title="helperFunctions.AppController.getInstalledApps" href="#helperFunctions.AppController.getInstalledApps">getInstalledApps</a></code></li>
<li><code><a title="helperFunctions.AppController.getParams" href="#helperFunctions.AppController.getParams">getParams</a></code></li>
<li><code><a title="helperFunctions.AppController.lock" href="#helperFunctions.AppController.lock">lock</a></code></li>
<li><code><a title="helperFunctions.AppController.readAppStore" href="#helperFunctions.AppController.readAppStore">readAppStore</a></code></li>
<li><code><a title="helperFunctions.AppController.readContainernames" href="#helperFunctions.AppController.readContainernames">readContainernames</a></code></li>
<li><code><a title="helperFunctions.AppController.readVersion" href="#helperFunctions.AppController.readVersion">readVersion</a></code></li>
<li><code><a title="helperFunctions.AppController.remove" href="#helperFunctions.AppController.remove">remove</a></code></li>
<li><code><a title="helperFunctions.AppController.setInfo" href="#helperFunctions.AppController.setInfo">setInfo</a></code></li>
<li><code><a title="helperFunctions.AppController.setParams" href="#helperFunctions.AppController.setParams">setParams</a></code></li>
<li><code><a title="helperFunctions.AppController.setProxyFiles" href="#helperFunctions.AppController.setProxyFiles">setProxyFiles</a></code></li>
<li><code><a title="helperFunctions.AppController.setStatus" href="#helperFunctions.AppController.setStatus">setStatus</a></code></li>
<li><code><a title="helperFunctions.AppController.setUpLog" href="#helperFunctions.AppController.setUpLog">setUpLog</a></code></li>
<li><code><a title="helperFunctions.AppController.setup_logger" href="#helperFunctions.AppController.setup_logger">setup_logger</a></code></li>
<li><code><a title="helperFunctions.AppController.start" href="#helperFunctions.AppController.start">start</a></code></li>
<li><code><a title="helperFunctions.AppController.startNginx" href="#helperFunctions.AppController.startNginx">startNginx</a></code></li>
<li><code><a title="helperFunctions.AppController.status" href="#helperFunctions.AppController.status">status</a></code></li>
<li><code><a title="helperFunctions.AppController.stop" href="#helperFunctions.AppController.stop">stop</a></code></li>
<li><code><a title="helperFunctions.AppController.stopNginx" href="#helperFunctions.AppController.stopNginx">stopNginx</a></code></li>
<li><code><a title="helperFunctions.AppController.unlock" href="#helperFunctions.AppController.unlock">unlock</a></code></li>
<li><code><a title="helperFunctions.AppController.writeCLICompose" href="#helperFunctions.AppController.writeCLICompose">writeCLICompose</a></code></li>
<li><code><a title="helperFunctions.AppController.writeCompose" href="#helperFunctions.AppController.writeCompose">writeCompose</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.9.1</a>.</p>
</footer>
</body>
</html>